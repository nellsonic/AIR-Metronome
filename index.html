<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Reliable Tempo Generator â€” ICU Sound</title>
  <style>
    body { background-color: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      text-align: center;
      padding: 20px;
    }
    input, select, button, label { margin: 5px; font-size: 1rem; }
    .section { margin: 1em 0; }
    .inline { display:inline-block; margin: 0 .25rem; }
    .muted { color:#b0b0b0; font-size:.9rem; }
  
  /* -- Pulse dot indicator (ICU-style minimal) -- */
  .pulse-wrap{display:flex;justify-content:center;margin-top:.3em;margin-bottom:.6em;pointer-events:none;}
  .pulse-dot{width:18px;height:18px;border-radius:999px;background:#60a5fa; /* matches sky-blue vibe */
    box-shadow:0 0 0 0 rgba(96,165,250,.55);opacity:0.0;margin:auto}
  .pulse-dot.boom{animation:pulse 320ms ease-out 1}
  @keyframes pulse{
    0%   {transform:scale(1); box-shadow:0 0 0 0 rgba(96,165,250,.55); opacity:0.0;}
    10%  {opacity:1;}
    60%  {transform:scale(2.4); box-shadow:0 0 0 16px rgba(96,165,250,.15); opacity:1;}
    100% {transform:scale(3.0); box-shadow:0 0 0 22px rgba(96,165,250,.05); opacity:0;}
  }


  .inline-btn{ display:inline-block; margin:0 .25rem; padding:.35rem .6rem; border:1px solid #444; border-radius:.5rem; background:#1e1e1e; color:#f0f0f0; cursor:pointer; }
  .inline-btn:active{ transform:translateY(1px); }

    /* Compact numeric boxes: ~4 chars incl. decimal */
    .n4 { width: 6.5ch; text-align: right; }
    .n4::-webkit-outer-spin-button,
    .n4::-webkit-inner-spin-button { margin: 0; }
    
  /* THEME TOKENS */
  :root{
    --bg:#121212;
    --panel:#1e1e1e;
    --text:#f0f0f0;
    --muted:#9aa0a6;
    --border:#2f2f2f;
    --accent:#60a5fa;
  }
  input,select,button,label{ color: var(--text); }
  input,select,button{
    background: var(--panel);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: .45rem;
    padding: .5rem .6rem;
  }
  label{ font-weight:600; color: var(--text); }
  .muted{ color: var(--muted); }
  .inline-btn{ border-color: var(--border); background: var(--panel); color: var(--text); }

  /* Pulse adopts accent */
  .pulse-dot{ background: var(--accent); box-shadow: 0 0 0 0 color-mix(in oklab, var(--accent) 55%, transparent); }
  @keyframes pulse{
    0%   {transform:scale(1); box-shadow:0 0 0 0 color-mix(in oklab, var(--accent) 55%, transparent); opacity:0.0;}
    10%  {opacity:1;}
    60%  {transform:scale(2.4); box-shadow:0 0 0 16px color-mix(in oklab, var(--accent) 15%, transparent); opacity:1;}
    100% {transform:scale(3.0); box-shadow:0 0 0 22px color-mix(in oklab, var(--accent) 5%, transparent); opacity:0;}
  }

  /* BLUE */
  :root[data-theme='blue']{
    --bg:#243b59;
    --panel:#2c4870;
    --text:#f5f8ff;
    --muted:#afc3db;
    --border:rgba(59,130,246,.30);
    --accent:#60a5fa;
  }
  /* YELLOW */
  :root[data-theme='yellow']{
    --bg:#E3B614;
    --panel:#D19B06;
    --text:#0b0b0b;
    --muted:#5b4a0c;
    --border:rgba(161,98,7,.45);
    --accent:#F2C316;
  }
  /* GREEN */
  :root[data-theme='green']{
    --bg:#0f2a22;
    --panel:#163a2f;
    --text:#f3fff8;
    --muted:#a7d3bf;
    --border:rgba(16,185,129,.35);
    --accent:#22c55e;
  }
  /* RED */
  :root[data-theme='red']{
    --bg:#2a0f12;
    --panel:#3a161b;
    --text:#fff5f6;
    --muted:#f3b3b9;
    --border:rgba(244,63,94,.35);
    --accent:#ef4444;
  }





/* Keep volume slider the same physical size as before */
#volume {
  width: 240px;
  vertical-align: middle;
}

/* Custom filled-track effect that reaches the far right at 100% */
#volume {
  /* Base track background (unfilled) uses panel color */
  background: linear-gradient(to right, var(--accent) 0%, var(--accent) 0%, var(--panel) 0%, var(--panel) 100%);
  background-repeat: no-repeat;
  border: 1px solid var(--border);
  border-radius: .45rem;
}

/* === Custom compact slider for #volume (fills fully at 100%) === */
#volume {
  width: 240px;              /* keep original size */
  height: 14px;
  appearance: none;
  -webkit-appearance: none;
  background:
    linear-gradient(var(--accent, #60a5fa) 0 0) no-repeat,
    linear-gradient(var(--panel, #1e1e1e) 0 0) no-repeat;
  background-size:
    calc((var(--volVal, 0) - var(--volMin, 0)) * 100% / max(1, (var(--volMax, 100) - var(--volMin, 0)))) 100%,
    100% 100%;
  border: 1px solid var(--border, #2f2f2f);
  border-radius: 999px;
  vertical-align: middle;
  outline: none;
}
/* WebKit thumb */
#volume::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--text, #f0f0f0);
  border: 2px solid var(--accent, #60a5fa);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent) 15%, transparent);
  margin-top: -2px; /* visually center on 14px track */
  cursor: pointer;
}
#volume::-webkit-slider-runnable-track {
  height: 14px;
  background: transparent;
  border: none;
}
/* Firefox track/progress */
#volume::-moz-range-track {
  height: 14px;
  background: var(--panel, #1e1e1e);
  border: 1px solid var(--border, #2f2f2f);
  border-radius: 999px;
}
#volume::-moz-range-progress {
  height: 14px;
  background: var(--accent, #60a5fa);
  border: 1px solid var(--border, #2f2f2f);
  border-radius: 999px;
}
#volume::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--text, #f0f0f0);
  border: 2px solid var(--accent, #60a5fa);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent) 15%, transparent);
  cursor: pointer;
}

/* Rounded fill edge for #volume at all positions including 100% */
#volume::-webkit-slider-runnable-track {
  border-radius: 999px;
  overflow: hidden;
}
#volume::-moz-range-progress {
  border-radius: 999px;
}
#volume::-moz-range-track {
  border-radius: 999px;
  overflow: hidden;
}

/* Adjust #volume slider height so the thumb visually fills space better */
#volume {
  height: 10px;
}
#volume::-webkit-slider-runnable-track {
  height: 10px;
}
#volume::-moz-range-track,
#volume::-moz-range-progress {
  height: 10px;
}
#volume::-webkit-slider-thumb {
  margin-top: -4px; /* recenter thumb vertically */
}

/* Refined proportions: thinner track, full circular thumb */
#volume {
  height: 14px;
}
#volume::-webkit-slider-runnable-track {
  height: 6px;
  margin-top: 4px;
  border-radius: 999px;
}
#volume::-moz-range-track,
#volume::-moz-range-progress {
  height: 6px;
  border-radius: 999px;
}
#volume::-webkit-slider-thumb {
  width: 18px;
  height: 18px;
  margin-top: -6px; /* centers circular thumb visually */
}

/* === Sleeker track + large circular thumb that stands out === */
#volume {
  width: 240px;           /* keep original width */
  height: 24px;           /* provide vertical room for a bigger thumb */
  vertical-align: middle;
}

/* WebKit/Blink */
#volume::-webkit-slider-runnable-track {
  height: 6px;            /* sleeker track */
  margin: 9px 0;          /* centers the track within the 24px control height */
  border-radius: 999px;
  background: transparent; /* we paint via gradients on the input itself */
}
#volume::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;            /* large, clearly circular knob */
  height: 20px;
  border-radius: 50%;
  background: var(--text, #f0f0f0);
  border: 2px solid var(--accent, #60a5fa);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent) 15%, transparent);
  cursor: pointer;
  margin-top: -7px;       /* centers the thumb over the 6px track ( (20-6)/2 = 7 ) */
}

/* Firefox */
#volume::-moz-range-track {
  height: 6px;            /* sleeker track */
  border-radius: 999px;
  background: var(--panel, #1e1e1e);
  border: 1px solid var(--border, #2f2f2f);
}
#volume::-moz-range-progress {
  height: 6px;
  border-radius: 999px;   /* rounded fill edge */
  background: var(--accent, #60a5fa);
  border: 1px solid var(--border, #2f2f2f);
}
#volume::-moz-range-thumb {
  width: 20px;            /* large circular knob */
  height: 20px;
  border-radius: 50%;
  background: var(--text, #f0f0f0);
  border: 2px solid var(--accent, #60a5fa);
  box-shadow: 0 0 0 2px color-mix(in oklab, var(--accent) 15%, transparent);
  cursor: pointer;
}

/* Keep the input's gradient-based fill so it reaches the right edge at 100% */
#volume {
  background:
    linear-gradient(var(--accent, #60a5fa) 0 0) no-repeat,
    linear-gradient(var(--panel, #1e1e1e) 0 0) no-repeat;
  background-size:
    calc((var(--volVal, 0) - var(--volMin, 0)) * 100% / max(1, (var(--volMax, 100) - var(--volMin, 0)))) 100%,
    100% 100%;
  border: 1px solid var(--border, #2f2f2f);
  border-radius: 999px;
}

/* === FINAL slider overrides: thin track, big round thumb, no thick frame === */
#volume {
  width: 240px;
  height: 24px;
  appearance: none;
  -webkit-appearance: none;
  border: 0 !important;
  padding: 0 !important;
  border-radius: 999px;
  /* Paint fill on the input itself so it reaches the right edge at 100% */
  background:
    linear-gradient(var(--accent, #60a5fa) 0 0) no-repeat,
    linear-gradient(var(--panel, #1e1e1e) 0 0) no-repeat;
  background-size:
    calc((var(--volVal, 0) - var(--volMin, 0)) * 100% / max(1, (var(--volMax, 100) - var(--volMin, 0)))) 100%,
    100% 100%;
}

/* WebKit/Blink track+thumb */
#volume::-webkit-slider-runnable-track {
  height: 6px;
  background: transparent;
  border: 0;
  border-radius: 999px;
}
#volume::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--text, #f0f0f0);
  border: 2px solid var(--accent, #60a5fa);
  margin-top: -7px; /* centers thumb over 6px track */
  box-shadow: none;
  cursor: pointer;
}

/* Firefox track/progress/thumb */
#volume::-moz-range-track {
  height: 6px;
  background: var(--panel, #1e1e1e);
  border: 0;
  border-radius: 999px;
}
#volume::-moz-range-progress {
  height: 6px;
  background: var(--accent, #60a5fa);
  border: 0;
  border-radius: 999px;
}
#volume::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--text, #f0f0f0);
  border: 2px solid var(--accent, #60a5fa);
  box-shadow: none;
  cursor: pointer;
}

/* === Native #volume slider: thin track, big round dot, full fill at 100% === */
input#volume {
  width: 240px !important;
  appearance: none !important;
  -webkit-appearance: none !important;
  background:
    linear-gradient(var(--accent, #60a5fa) 0 0) no-repeat,
    linear-gradient(var(--panel, #1e1e1e) 0 0) no-repeat !important;
  background-size: calc(var(--volPct, 0) * 1%) 100%, 100% 100% !important;
  border: 0 !important;
  padding: 0 !important;
  height: 24px !important;            /* overall control height */
  border-radius: 999px !important;
  vertical-align: middle !important;
  outline: none !important;
}

/* WebKit/Blink track + thumb */
input#volume::-webkit-slider-runnable-track {
  height: 6px !important;             /* thin track */
  background: transparent !important; /* we paint via the input's background */
  border: 0 !important;
  border-radius: 999px !important;
  margin: 9px 0 !important;           /* center track inside 24px control */
}
input#volume::-webkit-slider-thumb {
  -webkit-appearance: none !important;
  appearance: none !important;
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--text, #f0f0f0) !important;
  border: 2px solid var(--accent, #60a5fa) !important;
  box-shadow: none !important;
  margin-top: -7px !important;        /* center over 6px track */
  cursor: pointer !important;
}

/* Firefox */
input#volume::-moz-range-track {
  height: 6px !important;
  background: var(--panel, #1e1e1e) !important;
  border: 0 !important;
  border-radius: 999px !important;
}
input#volume::-moz-range-progress {
  height: 6px !important;
  background: var(--accent, #60a5fa) !important;
  border: 0 !important;
  border-radius: 999px !important;
}
input#volume::-moz-range-thumb {
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--text, #f0f0f0) !important;
  border: 2px solid var(--accent, #60a5fa) !important;
  box-shadow: none !important;
  cursor: pointer !important;
}

/* === Visible native #volume slider: thin track, round thumb, full fill === */
input#volume {
  width: 240px !important;
  appearance: none !important;
  -webkit-appearance: none !important;
  background:
    linear-gradient(var(--accent, #60a5fa) 0 0) no-repeat,
    linear-gradient(var(--panel, #1e1e1e) 0 0) no-repeat !important;
  background-size: calc(var(--volPct, 0) * 1%) 100%, 100% 100% !important;
  border: 0 !important;
  padding: 0 !important;
  height: 24px !important;            /* overall control height for centering */
  border-radius: 999px !important;
  vertical-align: middle !important;
  outline: none !important;
}

/* WebKit/Blink: thin track + large round thumb */
input#volume::-webkit-slider-runnable-track {
  height: 6px !important;
  background: transparent !important;
  border: 0 !important;
  border-radius: 999px !important;
  margin: 9px 0 !important;           /* center track inside control height */
}
input#volume::-webkit-slider-thumb {
  -webkit-appearance: none !important;
  appearance: none !important;
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--text, #f0f0f0) !important;
  border: 2px solid var(--accent, #60a5fa) !important;
  box-shadow: none !important;
  margin-top: -7px !important;        /* center over 6px track */
  cursor: pointer !important;
}

/* Firefox: use progress + track for fill */
input#volume::-moz-range-track {
  height: 6px !important;
  background: var(--panel, #1e1e1e) !important;
  border: 0 !important;
  border-radius: 999px !important;
}
input#volume::-moz-range-progress {
  height: 6px !important;
  background: var(--accent, #60a5fa) !important;
  border: 0 !important;
  border-radius: 999px !important;
}
input#volume::-moz-range-thumb {
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--text, #f0f0f0) !important;
  border: 2px solid var(--accent, #60a5fa) !important;
  box-shadow: none !important;
  cursor: pointer !important;
}
</style>
    
<style>

/* Sleek circular-dot slider styling (Volume) */
input#volume {
  appearance: none;
  -webkit-appearance: none;
  height: 28px; /* control height to center the thumb over a thin track */
  background: transparent;
  outline: none;
  padding: 0;
  margin: 0;
}
input#volume::-webkit-slider-runnable-track {
  height: 6px;
  background: var(--panel, #1e1e1e);
  border-radius: 999px;
  border: 1px solid var(--border, rgba(255,255,255,.15));
}
input#volume::-moz-range-track {
  height: 6px;
  background: var(--panel, #1e1e1e);
  border-radius: 999px;
  border: 1px solid var(--border, rgba(255,255,255,.15));
}
input#volume::-moz-range-progress {
  height: 6px;
  background: var(--accent, #60a5fa);
  border-radius: 999px;
}
input#volume::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--text, #f0f0f0);
  border: 2px solid var(--accent, #60a5fa);
  margin-top: -7px; /* centers 20px thumb over 6px track */
  cursor: pointer;
}
input#volume::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--text, #f0f0f0);
  border: 2px solid var(--accent, #60a5fa);
  cursor: pointer;
}

</style>
<style>

/* Bias slider (display-only mirror) */
input#biasSlider{
  appearance:none; -webkit-appearance:none;
  height:28px; background:transparent; outline:none; padding:0; margin:0 0 0 .25rem; opacity:.85;
}
input#biasSlider::-webkit-slider-runnable-track{
  height:6px; background:var(--panel,#1e1e1e); border-radius:999px;
  border:1px solid var(--border,rgba(255,255,255,.15));
}
input#biasSlider::-moz-range-track{
  height:6px; background:var(--panel,#1e1e1e); border-radius:999px;
  border:1px solid var(--border,rgba(255,255,255,.15));
}
input#biasSlider::-moz-range-progress{
  height:6px; background:var(--accent,#60a5fa); border-radius:999px;
}
input#biasSlider::-webkit-slider-thumb{
  -webkit-appearance:none; appearance:none;
  width:20px; height:20px; border-radius:50%;
  background:var(--text,#f0f0f0); border:2px solid var(--accent,#60a5fa);
  margin-top:-7px; cursor:default;
}
input#biasSlider::-moz-range-thumb{
  width:20px; height:20px; border-radius:50%;
  background:var(--text,#f0f0f0); border:2px solid var(--accent,#60a5fa);
  cursor:default;
}

</style>
</head>
<body></div>
  <h1>Randomizing & A.I.M. Metronome:</h1>
  <div id="currentTempoDisplay" style="font-size:1.8rem;font-weight:700;color:var(--accent);margin:.25em 0 .6em;">Current Tempo: <span id="currentTempo">60</span></div>
<div class="section" id="useCurrSection" style="text-align:center;">
    <input id="useCurrentAsStart" type="checkbox">
<label for="useCurrentAsStart">Use Current Tempo as Start Tempo</label>
  </div>
  <div class="pulse-wrap"><div id="pulseDot" class="pulse-dot"></div></div>


  <div class="section" id="themeRow" style="text-align:right;">
    <label for="themeSel" style="margin-right:.35rem;">Theme:</label>
    <select id="themeSel">
      <option value="">Default</option>
      <option value="blue">Blue</option>
      <option value="yellow">Yellow</option>
      <option value="green">Green</option>
      <option value="red">Red</option>
    </select>
  </div>


  <div class="section">
    <label for="startTempo">Start Tempo:</label>
<input type="number" id="startTempo" class="n4" min="10" max="300" step="0.5" value="60">
    <label for="minTempo">Min Tempo:</label>
<input type="number" id="minTempo" class="n4" min="10" max="300" step="0.5" value="40">
    <label for="maxTempo">Max Tempo:</label>
<input type="number" id="maxTempo" class="n4" min="10" max="300" step="0.5" value="120">
  </div>
  <div class="section" id="halfTemposRow">
    <input type="checkbox" id="halfBeats">
    <label for="halfBeats">Use Half-Beat Tempo Increments</label>
  </div>

  

  <div class="section">
    <label for="minChange">Min Change:</label>
<input type="number" id="minChange" class="n4" min="0" max="100" step="0.5" value="1">
    <label for="maxChange">Max Change:</label>
<input type="number" id="maxChange" class="n4" min="0" max="100" step="0.5" value="5">
    
  </div>

  <div class="section">
    <label for="beatsPerTempo">Beats per Tempo:</label>
<input type="number" id="beatsPerTempo" min="1" step="1" value="4" class="n4">
    <label for="subdivision">Subdivision:</label>
    <select id="subdivision">
      <option value="1">Quarter Notes</option>
      <option value="2">8th Notes</option>
      <option value="3">Triplets</option>
      <option value="4">16th Notes</option>
      <option value="5">5's</option>
      <option value="6">6's</option>
      <option value="7">7's</option>
    </select>
  </div>

    <div class="section">
    <label for="mode">Mode:</label>
    <select id="mode">
      <option value="random">Random</option>
      <option value="uponly">Up only</option>
      <option value="downonly">Down only</option>
    </select>
    <button id="biasDirBtn" type="button" class="inline">Bias: Up</button>
    <input type="number" id="biasPct" min="0" max="100" step="1" value="0" class="n4"> <input type="range" id="biasSlider" min="-100" max="100" step="1" disabled style="vertical-align:middle; width:240px;"> <input type="number" id="biasNum" min="-100" max="100" step="1" style="width:64px; margin-left:.5rem;">
<div class="biasNote" style="display:block;text-align:center;font-size:0.9em;color:var(--text-muted,#aaa);margin-top:0.5rem;line-height:1.3;">negative = more likely to go down, positive = more likely to go up</div>
<label for="biasPct">Bias %</label>
  </div>
<div class="section">
    
    <input type="checkbox" id="countIn">
<label for="countIn">Use Count-In Beats</label>
    <label for="countInBeats">Count-In Beats:</label>
<input type="number" id="countInBeats" min="1" step="1" value="4" class="n4">
    <input type="checkbox" id="countInSubdivs">
<label for="countInSubdivs">Include Subdivisions in Count-In</label>
  </div>

  <div class="section" id="volumeSection">
    <input type="range" id="volume" min="0" max="100" step="1" value="50" >
<label for="volume">Volume:</label>
    <input type="number" id="volumeNum" min="0" max="100" step="1" value="\1" style="width:64px; margin-left:.5rem;">
    <label class="inline" style="margin-left:10px;">
      <input id="allowFullVolume" type="checkbox">
      Allow full volume (louder clicks)
    </label>
  </div>

  <div class="section" id="pulseSection">
    <label class="inline" for="showPulse">Show pulse dot</label>
    <input id="showPulse" type="checkbox" checked>
  </div>
  <div class="section">
    <button id="startStop">Start</button>
    <span class="inline muted" id="status"></span>
      </div>

  <script>
  const $ = id => document.getElementById(id);

  
  // === Persistence helpers ===
  const LS_KEY_CURR = "RM_currentTempo";
  const LS_KEY_MODE = "RM_mode";
  const LS_KEY_BIAS_PCT = "RM_biasPct";
  const LS_KEY_BIAS_SIGN = "RM_biasSign";

  function saveMode(){ try{ localStorage.setItem(LS_KEY_MODE, $("mode").value); }catch(e){} }
  function loadMode(){ try{ return localStorage.getItem(LS_KEY_MODE) || "random"; }catch(e){ return "random"; } }

  function saveBiasPct(){ try{ localStorage.setItem(LS_KEY_BIAS_PCT, String(+$("biasPct").value||0)); }catch(e){} }
  function loadBiasPct(){ try{ const v = parseFloat(localStorage.getItem(LS_KEY_BIAS_PCT)); return isNaN(v)?0:v; }catch(e){ return 0; } }

  function saveBiasSign(){ try{ localStorage.setItem(LS_KEY_BIAS_SIGN, String(biasSign)); }catch(e){} }
  function loadBiasSign(){ try{ const v = parseInt(localStorage.getItem(LS_KEY_BIAS_SIGN)); return (v===-1)?-1:1; }catch(e){ return 1; } }

  const LS_KEY_USECURR = "RM_useCurrentAsStart";

  // === Persist all settings except volume ===
  const P_NUM_IDS = ["startTempo","minTempo","maxTempo","minChange","maxChange","beatsPerTempo","countInBeats"];
  const P_SEL_IDS = ["subdivision","mode"];
  const P_BOOL_IDS = ["halfBeats","countIn","showPulse","useCurrentAsStart","allowFullVolume","countInSubdivs"]; // persist allowFullVolume; exclude "volume"

  function lsKeyFor(id){ return "RM_" + id; }

  function saveSetting(id){
    const el = $(id); if(!el) return;
    const key = lsKeyFor(id);
    if (el.tagName === "SELECT"){
      try{ localStorage.setItem(key, el.value); }catch(e){}
    } else if (el.type === "checkbox"){
      try{ localStorage.setItem(key, el.checked ? "1" : "0"); }catch(e){}
    } else {
      try{ localStorage.setItem(key, String(el.value)); }catch(e){}
    }
  }
  function loadSetting(id){
    const el = $(id); if(!el) return;
    const key = lsKeyFor(id);
    try{
      const v = localStorage.getItem(key);
      if (v === null) return;
      if (el.tagName === "SELECT"){
        el.value = v;
      } else if (el.type === "checkbox"){
        el.checked = (v === "1");
      } else {
        el.value = v;
      }
    }catch(e){}
  }

  function attachPersistence(){
    P_NUM_IDS.forEach(id=>{
      const el = $(id); if(!el) return;
      el.addEventListener("input", ()=> saveSetting(id));
      el.addEventListener("change", ()=> saveSetting(id));
    });
    P_SEL_IDS.forEach(id=>{
      const el = $(id); if(!el) return;
      el.addEventListener("change", ()=> saveSetting(id));
    });
    P_BOOL_IDS.forEach(id=>{
      const el = $(id); if(!el) return;
      el.addEventListener("change", ()=> saveSetting(id));
    });
  }

  function loadAllSettings(){
    // Load primitive fields first
    [...P_NUM_IDS, ...P_SEL_IDS, ...P_BOOL_IDS].forEach(loadSetting);
    // Apply dependent UI updates
    applyHalfUI();
    updatePulseVisibility?.();
    applyModeUI?.();
    // Force Allow Full Volume off at load
    if ($("allowFullVolume")) $("allowFullVolume").checked = false;

    mirrorCurrentToStart?.();
  }

  // Load on DOM ready (before other 'load' handlers), then attach listeners
  window.addEventListener("DOMContentLoaded", ()=>{
    loadAllSettings();
    attachPersistence();
  });


  function saveCurrentTempo(){
    try { localStorage.setItem(LS_KEY_CURR, String(currentTempo)); } catch(e){}
  }
  function loadCurrentTempo(){
    try {
      const v = parseFloat(localStorage.getItem(LS_KEY_CURR));
      return isNaN(v) ? null : v;
    } catch(e){ return null; }
  }
  function saveUseCurrFlag(){
    try { localStorage.setItem(LS_KEY_USECURR, ($("useCurrentAsStart")?.checked ? "1":"0")); } catch(e){}
  }
  function loadUseCurrFlag(){
    try { return localStorage.getItem(LS_KEY_USECURR) === "1"; } catch(e){ return false; }
  }

  // === ICU click sound (main) ===
  // Distinct count-in click (SUB_B64 from ICU)
  const SUB_B64 = `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`;

  const MAIN_B64 = `UklGRkYEAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YSIEAAAAADRk1H7/f/9//3//f/9//38Rf4xlTQMwnWuBAIAAgACAAIAAgACAs4ApmWb5XWFSfv9//3//f/9//3//f4R/E2joCSSg84EAgACAAIAAgACAAIBGgLmW0PJPXsN9/3//f/9//3//f/9/7H9ranIQUKOJggCAAIAAgACAAIAAgACAepRK7OhaDH3/f/9//3//f/9//3/xf3prZBZDqPSDAIAAgACAAIAAgACAVoC+lBjneVTwev9//3//f/9//3//f1p/+mpDG+GuSIYAgACAAIAAgACAAID9gFuVkuKzTV94/3//f/9//3//f/9/o34+anEfyrUZiQCAAIAAgACAAIAAgMWBOJa13qtGS3X/f/9//3//f/9//3/GfUJp/iLmvHWMAIAAgACAAIAAgACAt4JTl3vbgT+kcUZ//3//f/9//3//f7x8AWjlJRTEaJCLgQCAAIAAgACAAIDdg7iY5dhVOGNthn3/f/9//3//f/9/eXt2ZiwoPMv6lIaDAIAAgACAAIAAgEGFbZro1j0xf2hKe/9//3//f/9//3/weZdk4Ck40jGaCIYAgACAAIAAgCuA84Z7nIDVXir2Ynt4YX//f/9//38zfxF4WGL8KvPYCaAsiYSBAIAAgACAhIEEie2eqtTNI9Fc/HRzff9//3//f6t9yHWuX4grVd96pgyNvIN4gACAU4BDg4qL0qFl1KMdGla0cOd6mX6Wf9d+rXv9coxcgytI5XKtwpGmhn2CVIEfgoeFoY41pbTU7RfjToprk3c9fJV9wXwYeZRv4FjvKrrq37Rnl3CKO4Wug4yEd4hnki6pjtW8EkZHZ2VIcw151nrveb91aGuYVMkpp++kvAqeSI/tiOWG04dGjAOXy63/1hYOZT8/XtVtyHQWdyN2a3FSZqFPFSj/853EtaVkldiNQos3jDCRnZwhswHZDApdNxFWBWcnbwdyEHHaayVg50nEJcP3rcxirvKcRZQakQ+Sepdlo0W5nduZBk4v7EytXtdnTWteasFktVhTQ9wi5fqv1P23GqaJnNGYuJl1n4yrTsDS3sQDXCfjQrRUjF6CYqRh01vQT9Y7WB9o/YTcasLqsOimx6KVo2qpO7VIyKvijwGsHx04D0kMU0dXiVbGUE5FWzMvG0r/D+R5zVq9k7NTrwSwn7WSwELRIucAAFEY1CzeOzhFXkm8SGNDHDngKV8WjAA06+7YQcuLwp6+NL81xKDNPdtF7BH/YhFAIVktKzW6OCo4nTM9K2If5xAsAeTxkORJ2pHTidAV0RrVT9w35hLyvv70CqAV3h1GI6wlEyWwIc4b8hPGCiwBDPgm8BTqLeaV5Dnl7+dk7BfyiPgR/xUFKwrtDSoQ2BAWEBYOLQurBwIEjACh/Wz7Fvqa+ef50PoX/Hf9uf6d/w==`;

  // Utility: snap to whole or half values depending on UI toggle
  const numIds = ["startTempo","minTempo","maxTempo","minChange","maxChange"];
  function snap(v, halves){ const step = halves?0.5:1; return Math.round(v/step)*step; }
  function applyHalfUI(){const halves = $("halfBeats").checked;
    numIds.forEach(id=>{
      const el=$(id);
      el.step = halves?"0.5":"1";
      const val = parseFloat(el.value||0);
      el.value = snap(val, halves).toFixed(halves?1:0);
    });
    $("currentTempo").textContent = snap(parseFloat($("currentTempo").textContent||0), halves).toFixed(halves?1:0);
  
    mirrorCurrentToStart();
}
  $("halfBeats").addEventListener("change", applyHalfUI);
  window.addEventListener("DOMContentLoaded", applyHalfUI);

  
  // Mirror: if enabled, copy currentTempo -> startTempo immediately
  function mirrorCurrentToStart(){
    if ($("useCurrentAsStart") && $("useCurrentAsStart").checked){
      $("startTempo").value = currentTempo.toFixed($("halfBeats").checked?1:0);
    }
  }


  // === Bias direction toggle ===
  let biasSign = 1; // +1 = Up, -1 = Down
  function updateBiasButton(){
    const btn = $("biasDirBtn");
    if(!btn) return;
    btn.textContent = biasSign > 0 ? "Bias: Up" : "Bias: Down";
  }
  window.addEventListener("load", updateBiasButton);
  $("biasDirBtn").addEventListener("click", ()=>{ biasSign *= -1; updateBiasButton(); });

  
  // === Mode & bias UI state ===
  function applyModeUI(){
    const mode = $("mode").value;
    const btn = $("biasDirBtn");
    const pct = $("biasPct");
    if(mode === "random"){
      // restore saved biasPct and biasSign
      const savedPct = loadBiasPct();
      biasSign = loadBiasSign();
      if(pct){ pct.disabled = false; pct.value = String(savedPct); }
      if(btn){ btn.disabled = false; updateBiasButton(); }
    }else{
      // freeze bias controls and display 0%
      if(pct){ pct.disabled = true; pct.value = "0"; }
      if(btn){ btn.disabled = true; btn.textContent = "Bias: (disabled)"; }
    }
  }

  // Load mode & bias on startup
  window.addEventListener("load", ()=>{
    // mode
    const m = loadMode();
    if($("mode")) $("mode").value = m;
    // bias values (only take effect in Random via applyModeUI)
    const savedPct = loadBiasPct();
    biasSign = loadBiasSign();
    if($("biasPct")) $("biasPct").value = String(savedPct);
    updateBiasButton();
    // finally apply UI enable/disable
    applyModeUI();
  });

  // Save on changes
  $("mode").addEventListener("change", ()=>{ saveMode(); applyModeUI(); });
  $("biasPct").addEventListener("input", ()=>{ saveBiasPct(); });
  // biasSign saved when toggled
  const _origBiasClick = $("biasDirBtn").onclick;
  $("biasDirBtn").addEventListener("click", ()=>{ saveBiasSign(); });

  
  // === Theme selection/persistence ===
  const LS_KEY_THEME = "RM_theme";
  function applyTheme(value){
    const v = value || "";
    try{
      if(v) document.documentElement.setAttribute("data-theme", v);
      else document.documentElement.removeAttribute("data-theme");
    }catch(e){}
  }
  function saveTheme(){
    try{ localStorage.setItem(LS_KEY_THEME, $("themeSel").value || ""); }catch(e){}
    applyTheme($("themeSel").value);
  }
  function loadTheme(){
    try{ return localStorage.getItem(LS_KEY_THEME) || ""; }catch(e){ return ""; }
  }
  window.addEventListener("DOMContentLoaded", ()=>{
    const t = loadTheme();
    if($("themeSel")) $("themeSel").value = t;
    applyTheme(t);
    $("themeSel")?.addEventListener("change", saveTheme);
  });

  // === Web Audio (master gain + decoded click buffer) ===
  let audioCtx = null, masterGain = null, clickBuf = null, countBuf = null;

  async function ensureAudio(){ 
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.connect(audioCtx.destination);
    }
    if(audioCtx.state === "suspended"){ try{ await audioCtx.resume(); }catch(_ ){} }
    if(!clickBuf){ clickBuf = await decodeB64ToBuffer(MAIN_B64); }
    if(!countBuf && SUB_B64){ countBuf = await decodeB64ToBuffer(SUB_B64); }
    // apply current slider value
    setEffectiveGainFromSlider();
  }

  async function decodeB64ToBuffer(b64){ 
    if(!b64) return null;
    try{ 
      const bin = atob(b64.trim());
      const len = bin.length;
      const arr = new Uint8Array(len);
      for(let i=0;i<len;i++) arr[i] = bin.charCodeAt(i);
      return await new Promise((resolve, reject)=>{
        audioCtx.decodeAudioData(arr.buffer, resolve, reject);
      });
    }catch(e){ console.warn("decode failed", e); return null; }
  }

  
  function playCountClick(){ 
    if(!audioCtx || !countBuf){ playClick(true); return; } // fallback to accent if no alt sample
    const src = audioCtx.createBufferSource();
    src.buffer = countBuf;
    const g = audioCtx.createGain();
    g.gain.value = 1.8; // maximum clarity
    src.connect(g).connect(masterGain);
    try{ src.start(); }catch(_ ){} 
  }

  function playClick(accent){ 
    if(!audioCtx || !clickBuf) return;
    const src = audioCtx.createBufferSource();
    src.buffer = clickBuf;
    const g = audioCtx.createGain();
    // Accented beats a bit louder
    g.gain.value = accent ? 1.0 : 0.45;
    src.connect(g).connect(masterGain);
    try{ src.start(); }catch(_ ){} 
  }

  // === Volume handling (ICU-style) ===
  function setEffectiveGainFromSlider(){
    const v = (+$("volume").value||0);
    const allowFull = !!$("allowFullVolume")?.checked;
    const raw = Math.max(0, Math.min(1, v/100));
    const SAFE_ATTEN = 0.4; // approx inverse of louder sample
    const eff = allowFull ? raw : (raw * SAFE_ATTEN);
    if(masterGain) masterGain.gain.value = eff;
  }

  // Initialize displayed value and effective gain
  // Load persisted current tempo and checkbox state on startup
  window.addEventListener("load", ()=>{
    const saved = loadCurrentTempo();
    if(saved && isFinite(saved)){
      currentTempo = Math.max(10, saved);
      $("currentTempo").textContent = currentTempo.toFixed($("halfBeats").checked?1:0);
    saveCurrentTempo();
    if ($("useCurrentAsStart") && $("useCurrentAsStart").checked){ $("startTempo").value = currentTempo.toFixed($("halfBeats").checked?1:0); }
          saveCurrentTempo();
          if ($("useCurrentAsStart") && $("useCurrentAsStart").checked){ $("startTempo").value = currentTempo.toFixed($("halfBeats").checked?1:0); }
    }
    const flag = loadUseCurrFlag();
    if($("useCurrentAsStart")) $("useCurrentAsStart").checked = !!flag;
    if(flag){ mirrorCurrentToStart(); }
  });
  // Persist checkbox state when toggled
  $("useCurrentAsStart")?.addEventListener("change", ()=>{ saveUseCurrFlag(); mirrorCurrentToStart(); });

  window.addEventListener("load", ()=>{
    $("volVal").textContent = String(Math.round(+$("volume").value||0));
    setEffectiveGainFromSlider();
  });

  // Live updates
  $("allowFullVolume")?.addEventListener("change", ()=>{ setEffectiveGainFromSlider(); });
  $("volume").addEventListener("input", ()=>{
    const v = (+$("volume").value||0);
    $("volVal").textContent = String(Math.round(v));
    setEffectiveGainFromSlider();
  });
  $("volume").addEventListener("change", ()=>{ $("volume").blur(); });
  // === Pulse dot handling ===
  function pulseBoom(){
    const chk = $("showPulse");
    const dot = $("pulseDot");
    if(!dot || !chk || !chk.checked) return;
    dot.classList.remove("boom");
    // reflow to restart animation
    void dot.offsetWidth;
    dot.classList.add("boom");
  }
  function updatePulseVisibility(){
    const dot = $("pulseDot");
    if(!dot) return;
    const on = !!$("showPulse")?.checked;
    dot.style.display = on ? "block" : "none";
  }
  window.addEventListener("load", updatePulseVisibility);
  $("showPulse").addEventListener("change", updatePulseVisibility);


  
  function getCountInBeats(){
    const v = Math.max(1, parseInt($("countInBeats")?.value||4));
    return v;
  }

  // === State ===
  let running=false;
  let tickerTimer=null;
  let currentTempo = 60;
  let subIdx = 0;           // subdivision index within a beat
  let beatInBlock = 0;      // beat index within current block
  let counting = false;     // count-in phase flag

  function clamp(v,min,max){ return Math.min(max, Math.max(min,v)); }

  function computeNextTempo(){
    const halves = $("halfBeats").checked;
    const minT = parseFloat($("minTempo").value)||40;
    const maxT = parseFloat($("maxTempo").value)||120;
    const minC = Math.max(0, parseFloat($("minChange").value)||1);
    const maxC = Math.max(minC, parseFloat($("maxChange").value)||3);
    const stepBase = minC + Math.random()*(maxC-minC);
    const step = snap(stepBase, halves);
    const mode = $("mode").value;
    const absBias = Math.max(0, Math.min(100, parseFloat($("biasPct").value)||0));
let dir = 0;
if (mode==="uponly") dir=1; else if (mode==="downonly") dir=-1; else {
  const pUp = Math.max(0, Math.min(1, (absBias * biasSign + 100) / 200));
  dir = (Math.random() < pUp) ? 1 : -1;
}
    let next = currentTempo + dir*step;
    next = clamp(snap(next, halves), minT, maxT);
    return Math.max(10, next);
  }

  function tick(){
    if(!running) return;

    // Read live controls (so changes take effect immediately)
    const subdiv = Math.max(1, parseInt($("subdivision").value)||1);
    const beatsPerTempo = Math.max(1, parseInt($("beatsPerTempo").value)||4);
    const countBeats = getCountInBeats();
// Sound for this tick
    if (counting){
      if (subIdx===0){ playCountClick(); pulseBoom(); } // main beat of count-in
      else {
        if ($("countInSubdivs")?.checked) { playClick(false); pulseBoom(); }
      }
    } else {
      if (subIdx===0) pulseBoom();
      playClick(subIdx===0);           // accent on the beat, lighter on subs
    }

    // Advance indices
    subIdx = (subIdx + 1) % subdiv;
    if (subIdx === 0){
      beatInBlock++;
      if (beatInBlock >= (counting ? countBeats : beatsPerTempo)){
        beatInBlock = 0;
        if (counting){
          counting = false; // finished count-in, enter main block
        } else {
          currentTempo = computeNextTempo();
          $("currentTempo").textContent = currentTempo.toFixed($("halfBeats").checked?1:0);
          counting = $("countIn").checked; // decide next block type live
        }
      }
    }

    // Schedule next tick using *current* tempo/subdivision so changes apply immediately
    const msPerSub = (60000 / currentTempo) / subdiv;
    tickerTimer = setTimeout(tick, msPerSub);
  }

  async function start(){
    if(running) return;
    await ensureAudio();
    applyHalfUI();
    currentTempo = clamp(
      snap(parseFloat($("startTempo").value)||60, $("halfBeats").checked),
      parseFloat($("minTempo").value)||40,
      parseFloat($("maxTempo").value)||120
    );
    $("currentTempo").textContent = currentTempo.toFixed($("halfBeats").checked?1:0);
    subIdx = 0; beatInBlock = 0; counting = $("countIn").checked;
    running=true;
    $("startStop").textContent="Stop";
    $("status").textContent="Running";
    tick();
  }
  function stop(){
    if(!running) return;
    running=false;
    clearTimeout(tickerTimer);
    $("startStop").textContent="Start";
    $("status").textContent="";
    saveCurrentTempo();
  }

  $("startStop").addEventListener("click", ()=> running?stop():start());
  window.addEventListener("keydown", (e)=>{ if(e.code==="Space"){ e.preventDefault(); running?stop():start(); }});
  </script>

<script>
// Enforce: maxChange cannot be smaller than minChange
(function(){
  const $ = id => document.getElementById(id);
  function snap(v, halves){ const step = halves?0.5:1; return Math.round(v/step)*step; }
  function halves(){ return !!document.getElementById('halfBeats')?.checked; }
  function fmt(v){ return snap(parseFloat(v||0), halves()).toFixed(halves()?1:0); }
  function enforce() {
    const minEl = $('minChange');
    const maxEl = $('maxChange');
    if(!minEl || !maxEl) return;
    let minV = parseFloat(minEl.value||0);
    let maxV = parseFloat(maxEl.value||0);
    if (isNaN(minV)) minV = 0;
    if (isNaN(maxV)) maxV = 0;
    if (maxV < minV) {
      maxV = minV;
      maxEl.value = fmt(maxV);
      // persist via existing saveSetting if available
      try { if (typeof saveSetting === 'function') saveSetting('maxChange'); } catch(_){}
    }
  }
  ['minChange','maxChange','halfBeats'].forEach(id=>{
    const el = $(id);
    if(!el) return;
    el.addEventListener('input', enforce);
    el.addEventListener('change', enforce);
  });
  // Run once on load
  window.addEventListener('DOMContentLoaded', enforce);
})();
</script>





<script>
(function(){
  function setVolVars(){
    var el = document.getElementById('volume');
    if(!el) return;
    var min = +el.min || 0;
    var max = +el.max || 100;
    var val = +el.value || 0;
    el.style.setProperty('--volMin', String(min));
    el.style.setProperty('--volMax', String(max));
    el.style.setProperty('--volVal', String(val));
  }
  window.addEventListener('DOMContentLoaded', setVolVars);
  window.addEventListener('load', setVolVars);
  document.addEventListener('input', function(ev){
    if(ev && ev.target && ev.target.id === 'volume'){ setVolVars(); }
  }, true);
  document.addEventListener('change', function(ev){
    if(ev && ev.target && ev.target.id === 'volume'){ setVolVars(); }
  }, true);
})();
</script>


<script>
(function(){
  function setVolPct(){
    var el = document.getElementById('volume');
    if(!el) return;
    var min = +el.min || 0, max = +el.max || 100, val = +el.value || 0;
    var pct = (val - min) * 100 / (max - min);
    if (!isFinite(pct)) pct = 0;
    // Snap to 100 exactly at max to avoid subpixel gaps
    if (val >= max) pct = 100;
    el.style.setProperty('--volPct', pct);
  }
  window.addEventListener('DOMContentLoaded', setVolPct);
  window.addEventListener('load', setVolPct);
  var vol = document.getElementById('volume');
  if (vol){
    vol.addEventListener('input', setVolPct);
    vol.addEventListener('change', setVolPct);
  }
})();
</script>


<script>
(function(){
  function setVolPct(){
    var el = document.getElementById('volume');
    if(!el) return;
    var min = +el.min || 0, max = +el.max || 100, val = +el.value || 0;
    var pct = (val - min) * 100 / (max - min);
    if (!isFinite(pct)) pct = 0;
    if (val >= max) pct = 100;  // lock to 100 so the fill hits the edge
    el.style.setProperty('--volPct', pct);
  }
  window.addEventListener('DOMContentLoaded', setVolPct);
  window.addEventListener('load', setVolPct);
  var vol = document.getElementById('volume');
  if (vol){
    vol.addEventListener('input', setVolPct);
    vol.addEventListener('change', setVolPct);
  }
})();
</script>


<script>
(function(){
  function $(id){ return document.getElementById(id); }
  function gateBias(){
    var modeEl = $("mode");
    var pct = $("biasPct");
    var btn = $("biasDirBtn");
    if(!modeEl) return;
    var disabled = (modeEl.value !== "random");
    if (pct){ pct.disabled = disabled; pct.style.opacity = disabled ? ".5" : "1"; }
    if (btn){ btn.disabled = disabled; btn.style.opacity = disabled ? ".5" : "1"; }
    // If disabled, normalize bias to 0 so logic ignores any stored bias
    if (disabled && pct){ pct.value = "0"; }
  }
  window.addEventListener("DOMContentLoaded", function(){
    var modeEl = $("mode");
    if (modeEl && !modeEl._biasGateBound){
      modeEl.addEventListener("change", gateBias);
      modeEl.addEventListener("input", gateBias);
      modeEl._biasGateBound = true;
    }
    gateBias();
  });
  window.addEventListener("load", gateBias);
})();
</script>


<script>
(function(){
  function clamp(v, min, max){ v = +v; if (isNaN(v)) return min; return Math.min(max, Math.max(min, v)); }
  function bindVolumeBox(){
    var slider = document.getElementById('volume');
    var box    = document.getElementById('volumeNum');
    if(!slider || !box) return;
    // initialize
    box.value = String(clamp(slider.value, 0, 100));
    slider.addEventListener('input', function(){
      box.value = String(clamp(slider.value, 0, 100));
    });
    slider.addEventListener('change', function(){
      box.value = String(clamp(slider.value, 0, 100));
    });
    function applyFromBox(){
      var v = clamp(box.value, 0, 100);
      box.value = String(v);
      slider.value = String(v);
      // Fire input on slider so existing gain logic runs
      slider.dispatchEvent(new Event('input', {bubbles:true}));
      slider.dispatchEvent(new Event('change', {bubbles:true}));
    }
    box.addEventListener('input', applyFromBox);
    box.addEventListener('change', applyFromBox);
  }
  window.addEventListener('DOMContentLoaded', bindVolumeBox);
  window.addEventListener('load', bindVolumeBox);
})();
</script>


<script>
(function(){
  function halfStep(){ var hb=document.getElementById('halfBeats'); return hb && hb.checked ? 0.5 : 1; }
  function snapTempo(v){ var s=halfStep(); v=+v||0; return Math.round(v/s)*s; }
  function fmt(v){ return (halfStep()===0.5) ? Number(v).toFixed(1) : String(Math.round(v)); }

  function applyHalfBeatToInputs(){
    var step = (halfStep()===0.5) ? 0.5 : 1;
    ['startTempo','minTempo','maxTempo'].forEach(function(id){
      var el = document.getElementById(id);
      if(!el) return;
      el.step = String(step);
      var v = parseFloat(el.value);
      if(!isNaN(v)){ el.value = fmt(snapTempo(v)); }
    });
  }
  function resnapCurrentDisplay(){
    var el = document.getElementById('currentTempoValue') || document.getElementById('currentTempo');
    if(!el) return;
    var num = parseFloat(el.textContent || el.innerText || '');
    if(isNaN(num)) return;
    var s = fmt(snapTempo(num));
    if(el.textContent !== undefined) el.textContent = s; else el.innerText = s;
  }

  window.addEventListener('load', function(){
    applyHalfBeatToInputs();
    var hb = document.getElementById('halfBeats');
    if(hb){
      hb.addEventListener('change', function(){ applyHalfBeatToInputs(); resnapCurrentDisplay(); });
      hb.addEventListener('input', function(){ applyHalfBeatToInputs(); resnapCurrentDisplay(); });
    }
    // snap when user edits boxes
    ['startTempo','minTempo','maxTempo'].forEach(function(id){
      var el = document.getElementById(id);
      if(el){
        function norm(){ el.value = fmt(snapTempo(el.value)); }
        el.addEventListener('change', norm);
        el.addEventListener('blur', norm);
      }
    });
  });
})();
</script>


<script>
(function(){
  function clamp(v, min, max){ v = +v; if (isNaN(v)) return 0; return Math.min(max, Math.max(min, v)); }
  function $(id){ return document.getElementById(id); }

  function updateBiasNumFromPct(){
    var pct = $("biasPct");
    var box = $("biasNum");
    if(!pct || !box) return;
    box.value = String(clamp(pct.value, -100, 100));
  }

  function updateBiasPctFromNum(){
    var pct = $("biasPct");
    var box = $("biasNum");
    if(!pct || !box) return;
    var v = clamp(box.value, -100, 100);
    box.value = String(v);
    pct.value = String(v);
    // If your code saves bias automatically, trigger its events
    pct.dispatchEvent(new Event('input', {bubbles:true}));
    pct.dispatchEvent(new Event('change', {bubbles:true}));
  }

  function bindBiasSync(){
    var pct = $("biasPct");
    var box = $("biasNum");
    var btn = $("biasDirBtn");
    if (pct && box){
      // initialize
      updateBiasNumFromPct();
      pct.addEventListener('input', updateBiasNumFromPct);
      pct.addEventListener('change', updateBiasNumFromPct);
      box.addEventListener('input', updateBiasPctFromNum);
      box.addEventListener('change', updateBiasPctFromNum);
    }
    // If there is a bias up/down direction button, keep number in sync after clicks
    if (btn){
      btn.addEventListener('click', function(){ setTimeout(updateBiasNumFromPct, 0); });
    }
  }

  // Extend the existing mode gate (if present) to include the number box
  function extendGate(){
    var modeEl = $("mode");
    var pct = $("biasPct");
    var btn = $("biasDirBtn");
    var box = $("biasNum");
    if(!modeEl) return;
    var disabled = (modeEl.value !== "random");
    if (box){
      box.disabled = disabled;
      if (disabled) { box.value = "0"; }
    }
  }

  window.addEventListener('DOMContentLoaded', function(){
    bindBiasSync();
    extendGate();
    var modeEl = $("mode");
    if (modeEl && !modeEl._biasNumGateBound){
      modeEl.addEventListener('change', extendGate);
      modeEl.addEventListener('input', extendGate);
      modeEl._biasNumGateBound = true;
    }
  });
  window.addEventListener('load', function(){
    bindBiasSync();
    extendGate();
  });
})();
</script>


<script>
(function(){
  try{
    var pct = document.getElementById('biasPct');
    var sl  = document.getElementById('biasSlider');
    if (!pct || !sl) return;
    function mirror(){ sl.value = String(pct.value || 0); }
    mirror();
    pct.addEventListener('input', mirror);
    pct.addEventListener('change', mirror);
    // Mode gating: keep it disabled always (display-only)
  }catch(e){ /* do nothing */ }
})();
</script>


<script>
(function(){
  try{
    function $(id){ return document.getElementById(id); }
    function clamp(v,min,max){ v = +v; if(isNaN(v)) return 0; return Math.min(max, Math.max(min, v)); }

    var SYNCING = false; // prevents feedback loops

    // Set all bias controls to the same value.
    // opts.emit: if true, fire events on the primary control (pct) so existing logic reacts.
    function setAllBias(val, opts){
      var pct = $('biasPct');
      var num = $('biasNum');      // may or may not exist
      var sl  = $('biasSlider');   // exists
      var v = clamp(val, -100, 100);
      opts = opts || {emit:false};

      SYNCING = true;
      try{
        if (pct && pct.value != String(v)) pct.value = String(v);
        if (num && num.value != String(v)) num.value = String(v);
        if (sl  && sl.value  != String(v)) sl.value  = String(v);
      } finally {
        SYNCING = false;
      }
      if (opts.emit && pct){
        // Fire only one event to minimize risk; 'change' is usually sufficient for persistence
        try { pct.dispatchEvent(new Event('change', {bubbles:true})); } catch(_e){}
      }
    }

    function bind(){
      var pct  = $('biasPct');
      var num  = $('biasNum');
      var sl   = $('biasSlider');
      var mode = $('mode');
      if (!pct || !sl) return;

      // Initialize values from pct without emitting
      setAllBias(pct.value, {emit:false});

      // Slider drives bias when enabled
      function onSlider(){
        if (SYNCING) return;
        if (sl.disabled) return;
        setAllBias(sl.value, {emit:true});
      }
      sl.addEventListener('input', onSlider);
      sl.addEventListener('change', onSlider);

      // pct edits (from user or other logic) reflect without re-emitting
      function onPct(){
        if (SYNCING) return;
        setAllBias(pct.value, {emit:false});
      }
      pct.addEventListener('input', onPct);
      pct.addEventListener('change', onPct);

      // number box (if present) should emit so bias persists like normal
      if (num){
        function onNum(){
          if (SYNCING) return;
          setAllBias(num.value, {emit:true});
        }
        num.addEventListener('input', onNum);
        num.addEventListener('change', onNum);
      }

      // Gate enablement by mode
      function gate(){
        var disabled = (mode && mode.value !== 'random');
        if (sl)  sl.disabled  = !!disabled;
        if (num) num.disabled = !!disabled;
        if (pct) pct.disabled = !!disabled;
        if (disabled){
          setAllBias(0, {emit:true});
        } else {
          setAllBias(pct.value, {emit:false});
        }
      }
      if (mode){
        mode.addEventListener('change', gate);
        mode.addEventListener('input', gate);
      }
      gate();
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', bind);
    } else {
      bind();
    }
  }catch(_e){ /* swallow any unexpected errors to avoid blank screen */ }
})();
</script>

</body>
</html>