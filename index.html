<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A.I.R. Metronome — FIX19 + Deterministic Repeats Engine (UI Step 1k Unified Commit + Spacebar + CI Subs)</title>
<style>
  :root{
    /* Theme tokens */
    --bg:#0d1117; --fg:#e6edf3; --muted:#9fb0c3; --line:#2b3444; --panel:#0f1623;
    --accent:#4fb3ff; --ok:#49d39e; --gold:#ffcc3d; --danger:#ff6b6b;
    --input:#111a2b; --chip:#172235;

    /* UI scale tokens */
    --radii:12px;
    --radii-lg:16px;
    --gap-s:6px;
    --gap-m:12px;
    --gap-l:20px;

    --focus: 0 0 0 2px rgba(79,179,255,.4);
  }
  [data-theme="light"]{ --bg:#f4efe7; --fg:#1d2430; --muted:#5a606b; --line:#d9cfbf; --panel:#f5f1ea; --input:#ffffff; --chip:#fff9ef; --accent:#1a66ff; --ok:#0f8e64; --gold:#b07d00; }
  [data-theme="yellow"]{ --bg:#e1b507; --fg:#17130a; --muted:#3a301a; --line:#d0a908; --panel:#f0c427; --input:#fff4b4; --chip:#ffe780; --accent:#0f3b9e; --ok:#0f6c4a; --gold:#7a5600; }
  [data-theme="red"]{ --bg:#25080b; --fg:#ffecec; --muted:#ffb3b3; --line:#62222a; --panel:#2e0e13; --input:#3a141a; --chip:#47171d; --accent:#ff8aa0; --ok:#62e0b9; --gold:#ffd56b; }
  [data-theme="green"]{ --bg:#0b1c18; --fg:#e6fff7; --muted:#9ad5c3; --line:#1d3a33; --panel:#0f2621; --input:#12312a; --chip:#163b34; --accent:#7fe8ff; --ok:#56f0b9; --gold:#ffe18a; }

  /* Base */
  body{background:var(--bg); color:var(--fg); font:15px/1.45 system-ui,Segoe UI,Roboto,Inter,Arial; margin:0;}
  .wrap{max-width:980px; margin:24px auto 56px; padding:0 16px;}
  h1{margin:0 0 10px; font-weight:900; font-size:22px; letter-spacing:.2px;}
  .top{display:flex; align-items:center; justify-content:space-between; gap:12px}
  .tempo{font-size:36px; font-weight:900; letter-spacing:.5px}

  /* Controls */
  select, input[type=number], input[type=text]{
    width:100%; padding:8px 10px; border-radius:var(--radii); border:1px solid var(--line); background:var(--input); color:var(--fg);
    transition: box-shadow .15s ease, border-color .15s ease, background-color .15s ease;
  }
  input[type=range]{ width:100%; }

  select:focus, input:focus{ outline:none; box-shadow: var(--focus); border-color: transparent; }

  .btn{
    padding:10px 16px; border-radius:var(--radii); border:1px solid var(--line); background:var(--chip); color:var(--fg); cursor:pointer;
    transition: box-shadow .15s ease, filter .12s ease;
  }
  .btn:hover{ filter:brightness(1.05); }
  .btn:focus{ outline:none; box-shadow: var(--focus); border-color: transparent; }
  .btn.primary{background:var(--accent); color:#00142a; border-color:transparent; font-weight:700}

  .status{font-size:12px; color:var(--muted)}
  .panel{background:var(--panel); border:1px solid var(--line); border-radius:var(--radii-lg); padding:14px;}
  .grid{display:grid; grid-template-columns: repeat(auto-fit, minmax(210px,1fr)); gap:var(--gap-m);}
  .field label{display:block; color:var(--muted); font-size:12px; margin-bottom:5px;}
  .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
  .dot{width:14px; height:14px; border-radius:50%; background:#5a6578; display:inline-block; margin-left:8px}
  .inline{display:flex; align-items:center; gap:8px}
  .muter{position:relative}
  .menu{position:absolute; top:36px; right:0; width:260px; background:var(--panel); border:1px solid var(--line); border-radius:var(--radii); padding:10px; display:none; box-shadow:0 10px 30px rgba(0,0,0,.35)}
  .menu.open{display:block}
  .menu h4{margin:0 0 8px; font-size:13px; color:var(--muted)}
  .menu small{color:var(--muted)}
  .menu .list{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px}
  .chip{padding:6px 10px; border-radius:10px; background:var(--chip); border:1px solid var(--line); color:var(--fg)}
  .help{font-size:12px; color:var(--muted); margin-top:8px}
  .foot{margin-top:12px; font-size:12px; color:var(--muted)}
  .sr{position:absolute; left:-9999px}

  /* Slightly larger targets for touch */
  .menu input[type=checkbox]{ width:16px; height:16px; }
</style>
</head>
<body data-theme="dark">
<div class="wrap">
  <div class="top">
    <div>
      <h1>Automatic Incremental & Randomizing (A.I.R.) Metronome</h1>
      <div class="inline">
        <div class="tempo"><span id="tempoNow">60</span></div>
        <span class="status" id="status">Stopped</span>
        <span class="dot" id="pulse"></span>
      </div>
    </div>
    <div class="inline">
      <label class="sr" for="theme">Theme</label>
      <select id="theme">
        <option value="dark">Dark</option>
        <option value="light">Light (tan)</option>
        <option value="yellow">Yellow</option>
        <option value="red">Red</option>
        <option value="green">Green</option>
      </select>
      <button class="btn primary" id="startStop">Start</button>
    </div>
  </div>

  <div class="panel">
    <div class="grid">
      <div class="field"><label>Start Tempo</label><input id="startTempo" type="number" value="60" min="20" max="300"></div>
      <div class="field"><label>Min Tempo</label><input id="minTempo" type="number" value="40" min="20" max="300"></div>
      <div class="field"><label>Max Tempo</label><input id="maxTempo" type="number" value="180" min="20" max="300"></div>
      <div class="field"><label>Beats per Tempo</label><input id="beatsPerTempo" type="number" value="4" min="1" max="16"></div>
      <div class="field"><label>Repeats per Tempo</label><input id="repeatsPerTempo" type="number" value="2" min="1" max="64"></div>
      <div class="field"><label>Count-In Beats (every cycle)</label><input id="countInBeats" type="number" value="2" min="0" max="16"></div><div class="field"><label class="sr" for="includeSubdivisionsInCountOff">Include subdivisions in count-off</label><label class="inline"><input id="includeSubdivisionsInCountOff" type="checkbox" /> <span>Include subdivisions in count-off</span></label></div>
      <div class="field"><label>Subdivisions per Beat</label><input id="subsPerBeat" type="number" value="2" min="1" max="8"></div>
      <div class="field"><label>Min Change</label><input id="minStep" type="number" value="1" min="1" max="60"></div>
      <div class="field"><label>Max Change</label><input id="maxStep" type="number" value="5" min="1" max="60"></div>

      <!-- Bias controls: number + slider, synced on commit for number -->
      <div class="field">
        <label for="biasPct">Bias % (−100…+100)</label>
        <input id="biasPct" type="number" value="0" min="-100" max="100" step="1" aria-describedby="biasHelp">
        <input id="biasSlider" type="range" value="0" min="-100" max="100" step="1" style="margin-top:6px;">
        <div id="biasHelp" class="help">Negative = more likely to go down. Positive = more likely to go up.</div>
      </div>

      <div class="field"><label>Volume</label><input id="volume" type="range" value="60" min="0" max="100"></div>

      <div class="field muter">
        <label>Mute subdivisions</label>
        <button class="btn" id="muteBtn" aria-haspopup="dialog" aria-expanded="false">Mute subdivisions ▾</button>
        <div class="menu" id="muteMenu" role="dialog" aria-modal="true" aria-label="Subdivision muting menu"><label class="inline"><input id="applyToCountIn" type="checkbox"/> <span>Apply muting to count-in</span></label><div class="list" id="subList"></div><div class="help">Uncheck sub-notes to silence them. <button class="btn" id="resetMute">Unmute All</button></div></div></div></div>
    </div>

    <div class="foot">Live volume preview when stopped: move the volume slider. Space toggles Start/Stop.</div>
  </div>
</div>

<script>
(() => {
  // THEME
  const root = document.body;
  const themeSel = document.getElementById('theme');
  const pulse = document.getElementById('pulse');
  themeSel.addEventListener('change', () => { root.setAttribute('data-theme', themeSel.value); });
  root.setAttribute('data-theme', themeSel.value);

  // UI refs
  const tempoNow = document.getElementById('tempoNow');
  const statusEl = document.getElementById('status');
  const startBtn = document.getElementById('startStop');
  const startTempo = document.getElementById('startTempo');
  const minTempo = document.getElementById('minTempo');
  const maxTempo = document.getElementById('maxTempo');
  const beatsPerTempo = document.getElementById('beatsPerTempo');
  const repeatsPerTempo = document.getElementById('repeatsPerTempo');
  const countInBeats = document.getElementById('countInBeats');
  const subsPerBeat = document.getElementById('subsPerBeat');
  const minStep = document.getElementById('minStep');
  const maxStep = document.getElementById('maxStep');
  const biasPct = document.getElementById('biasPct');
  const biasSlider = document.getElementById('biasSlider');
  const volume = document.getElementById('volume');
  const muteBtn = document.getElementById('muteBtn');
  const muteMenu = document.getElementById('muteMenu');
  const subList = document.getElementById('subList');  const applyToCountIn = document.getElementById('applyToCountIn');
  const includeSubdivisionsInCountOff = document.getElementById('includeSubdivisionsInCountOff');
  const resetMute = document.getElementById('resetMute');

  // Bias sync
  function clampBias(v){
    v = Number(v);
    if (!Number.isFinite(v)) v = 0;
    v = Math.round(v);
    if (v < -100) v = -100;
    if (v > 100) v = 100;
    return v;
  }
  let syncingBias = false;
  function setBias(v){
    syncingBias = true;
    const vv = clampBias(v);
    biasPct.value = String(vv);
    biasSlider.value = String(vv);
    syncingBias = false;
  }
  function onBiasSlider(){ if (!syncingBias) setBias(biasSlider.value); }
  biasSlider.addEventListener('input', onBiasSlider);
  biasSlider.addEventListener('change', onBiasSlider);
  setBias(biasPct.value || 0);

  // Helpers
  function isNum(v){ return v !== '' && v !== null && v !== undefined && !isNaN(Number(v)); }
  const rint = (v)=> String(Math.round(Number(v)));

  // Commit-only range logic for Start/Min/Max
  let syncingRange = false;
  function enforceRange(sourceId){
    if (syncingRange) return;
    if (!isNum(minTempo.value) || !isNum(maxTempo.value) || !isNum(startTempo.value)) return;

    syncingRange = true;
    let minV = Number(minTempo.value);
    let maxV = Number(maxTempo.value);
    let startV = Number(startTempo.value);

    if (sourceId === 'maxTempo') {
      if (maxV < minV) { minV = maxV; minTempo.value = rint(minV); }
      if (startV < minV || startV > maxV) { startV = minV; startTempo.value = rint(startV); }
    } else if (sourceId === 'minTempo') {
      if (minV > maxV) { maxV = minV; maxTempo.value = rint(maxV); }
      if (startV < minV || startV > maxV) { startV = minV; startTempo.value = rint(startV); }
    } else if (sourceId === 'startTempo') {
      // Expand range to include start, without altering start
      if (startV < minV) { minV = startV; minTempo.value = rint(minV); }
      if (startV > maxV) { maxV = startV; maxTempo.value = rint(maxV); }
    } else {
      // Generic init
      if (minV > maxV) { maxV = minV; maxTempo.value = rint(maxV); }
      if (startV < minV || startV > maxV) { startV = minV; startTempo.value = rint(startV); }
    }

    syncingRange = false;
  }

  // Keep step range sane on commit
  function enforceStepRange(sourceId){
    let minV = Number(minStep.value);
    let maxV = Number(maxStep.value);
    if (!isNum(minV) || !isNum(maxV)) return;
    if (minV < 1) minV = 1;
    if (maxV < 1) maxV = 1;
    if (minV > maxV){
      if (sourceId === 'minStep') { maxV = minV; maxStep.value = rint(maxV); }
      else { minV = maxV; minStep.value = rint(minV); }
    } else {
      minStep.value = rint(minV);
      maxStep.value = rint(maxV);
    }
  }

  function bindCommit(el, onCommit){
    const commit = () => { onCommit && onCommit(); };
    el.addEventListener('change', commit);
    el.addEventListener('blur', commit);
    el.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' || e.code === 'Enter' || e.code === 'NumpadEnter' || e.keyCode === 13) {
        e.preventDefault();
        commit();
        el.blur();
      }
    });
    el.addEventListener('keyup', (e)=>{
      if (e.key === 'Enter' || e.code === 'Enter' || e.code === 'NumpadEnter' || e.keyCode === 13) {
        commit();
      }
    });
  }

  // Start/Min/Max with specialized enforcement
  bindCommit(minTempo, ()=>enforceRange('minTempo'));
  bindCommit(maxTempo, ()=>enforceRange('maxTempo'));
  bindCommit(startTempo, ()=>enforceRange('startTempo'));

  // Other numeric inputs: commit-only behavior + side effects
  bindCommit(beatsPerTempo, ()=>{});
  bindCommit(repeatsPerTempo, ()=>{});
  bindCommit(countInBeats, ()=>{});
  bindCommit(subsPerBeat, ()=>{ buildSubList(); });
  bindCommit(minStep, ()=>{ enforceStepRange('minStep'); });
  bindCommit(maxStep, ()=>{ enforceStepRange('maxStep'); });
  bindCommit(biasPct, ()=>{ setBias(biasPct.value); }); // sync number -> slider on commit

  // Initial pass
  enforceRange();
  enforceStepRange();

  // Popover
  function setMenuExpanded(open){
    muteBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
    muteMenu.classList.toggle('open', open);
  }
  muteBtn.addEventListener('click', (e) => { e.stopPropagation(); setMenuExpanded(!muteMenu.classList.contains('open')); buildSubList(); });
  document.addEventListener('click', (e)=>{
    if(!muteMenu.contains(e.target) && e.target!==muteBtn){ setMenuExpanded(false); }
  });
  resetMute.addEventListener('click', () => {
    [...subList.querySelectorAll('input[type=checkbox]')].forEach(cb=>cb.checked=true);
  });

  function buildSubList(){
    const n = Math.max(1, +subsPerBeat.value||1);    subList.innerHTML='';
    for(let i=1;i<=n;i++){
      const id='submute_'+i;
      const li=document.createElement('label'); li.className='inline chip';
      li.innerHTML=`<input type="checkbox" id="${id}" checked> <span>${i}</span>`;
      subList.appendChild(li);
    }
  }
  buildSubList();

  // AUDIO
  let ctx, buffers={};
  const AC = window.AudioContext || window.webkitAudioContext;
  function ensureCtx(){ if(!ctx){ ctx = new AC(); } return ctx.resume(); }
  function flash(kind){ pulse.style.background = kind==='ci'?'var(--gold)':kind==='beat'?'var(--accent)':'var(--ok)'; setTimeout(()=>pulse.style.background='#5a6578',85); }
  function makeTone(hz, len=0.038, decay=38){
    const sr=ctx.sampleRate, n=Math.floor(sr*len), buf=ctx.createBuffer(1,n,sr), ch=buf.getChannelData(0);
    for(let i=0;i<n;i++){ const tt=i/sr; ch[i]=Math.sin(2*Math.PI*hz*tt)*Math.exp(-tt*decay); }
    return buf;
  }
  async function loadBuffers(){
    if(Object.keys(buffers).length) return;
    await ensureCtx();
    buffers.ci   = makeTone(1400,0.045,42);
    buffers.beat = makeTone(950,0.040,40);
    buffers.sub  = makeTone(620,0.036,36);
    buffers.cisub = makeTone(940,0.036,36);
  }
  function play(bufName, when, gainMul=0.85){
    const now = ctx.currentTime;
    const src = ctx.createBufferSource(); src.buffer=buffers[bufName];
    const g = ctx.createGain(); g.gain.value = (parseInt(volume.value,10)/100)*gainMul;
    src.connect(g).connect(ctx.destination);
    src.start(Math.max(when, now));
  }
  // live preview when stopped
  let running=false;
  volume.addEventListener('input', ()=>{ if(!running){ ensureCtx().then(loadBuffers).then(()=>{ play('beat', ctx.currentTime+0.02, 0.5); }); } });

  // Deterministic scheduler
  let loop=null;
  function clampTempo(v){ const lo=+minTempo.value, hi=+maxTempo.value; return Math.min(hi, Math.max(lo, Math.round(v))); }
  function stepSize(){
    const min=+minStep.value, max=+maxStep.value, bias=+biasPct.value;
    const pUp=Math.max(0,Math.min(1,0.5+bias/200));
    const span=Math.max(0,max-min);
    const size=min+Math.floor(Math.random()*(span+1));
    return (Math.random()<pUp)? size : -size;
  }
  function mutedMask(n){
    const cbs=[...subList.querySelectorAll('input[type=checkbox]')];
    if(cbs.length!==n) return new Array(n).fill(true);
    return cbs.map(cb=>cb.checked);
  }

  function start(){
    if(running) return;
    running=true;
    ensureCtx().then(loadBuffers).then(()=>{
      // state vars
      let tempo = clampTempo(+startTempo.value||60);
      let bpt   = Math.max(1, +beatsPerTempo.value||4);
      let rptN  = Math.max(1, +repeatsPerTempo.value||1);
      let sub   = Math.max(1, +subsPerBeat.value||1);
      let ciN   = Math.max(0, +countInBeats.value||0);
      let mask  = mutedMask(sub);
      let includeMuteInCI = applyToCountIn.checked; // retained for future use
      let includeSubsInCI = includeSubdivisionsInCountOff && includeSubdivisionsInCountOff.checked;

      let beatInterval = 60/tempo;
      let subInterval  = beatInterval/sub;
      let next = ctx.currentTime + 0.12;

      let state = (ciN>0)? 'countin' : 'beats';
      let ciBeatsLeft=ciN;
      let beatIdx=0;
      let subSlot = 0; // 0..sub-1 (0 = main beat slot)
      let repsDone=0;
      let pendingTempo=false;

      tempoNow.textContent = tempo;
      statusEl.textContent = 'Running';
      startBtn.textContent = 'Stop';

      function refresh(){
        beatInterval = 60/tempo;
        subInterval  = beatInterval/sub;
      }

      function tempoAdvance(){
        const delta = stepSize();
        tempo = clampTempo(tempo + delta);
        tempoNow.textContent = tempo;
        // re-read dynamic form values
        bpt  = Math.max(1, +beatsPerTempo.value||4);
        rptN = Math.max(1, +repeatsPerTempo.value||1);
        sub  = Math.max(1, +subsPerBeat.value||1);
        ciN  = Math.max(0, +countInBeats.value||0);
        mask = mutedMask(sub);
        includeMuteInCI = applyToCountIn.checked;
        includeSubsInCI = includeSubdivisionsInCountOff && includeSubdivisionsInCountOff.checked;
        refresh();
      }

      const lookahead=0.12;
      function tick(){
        while(next < ctx.currentTime + lookahead){
          if(state==='countin'){
            // During count-off: optionally include muted subdivisions
            const includeSubsCI = includeSubdivisionsInCountOff && includeSubdivisionsInCountOff.checked;
            if(subSlot===0){
              // Play the count-off beat
              play('ci', next, 0.95); flash('ci');
              if(includeSubsCI){
                subSlot = 1;           // step into subdivisions
                next += subInterval;   // schedule first subdivision slot
              } else {
                // No subdivisions in count-off: jump to next whole beat
                next += (60/tempo);
                ciBeatsLeft--;
                if(ciBeatsLeft === 0){
                  beatIdx = 0; subSlot = 0; state = 'beats';
                }
              }
              continue;
            }
            if(includeSubsCI && subSlot < sub){
              const applyMuteCI = applyToCountIn && applyToCountIn.checked;
              const shouldPlay = applyMuteCI ? !!mask[subSlot] : true;
              if(shouldPlay){ play('cisub', next, 0.55); flash('sub'); }
              subSlot++;
              next += subInterval;
              if(subSlot < sub) continue;
              // finished all subdivisions for this beat
              ciBeatsLeft--;
              subSlot = 0;
              if(ciBeatsLeft === 0){
                beatIdx = 0; state = 'beats';
              }
              continue;
            }
          }

          // beats state
          if(subSlot===0){
            if(pendingTempo){ tempoAdvance(); pendingTempo=false; }
            refresh(); // lock intervals for this beat
            play('beat', next, 0.85); flash('beat');
            subSlot=1;
            next += subInterval; continue;
          }
          if(subSlot < sub){
            if(mask[subSlot]){ play('sub', next, 0.55); flash('sub'); }
            subSlot++;
            next += subInterval;
            if(subSlot < sub) continue;
          }
          // beat finished
          beatIdx++;
          if(beatIdx < bpt){ subSlot=0; continue; }

          // cycle finished
          repsDone++;
          if(repsDone >= rptN){ repsDone=0; pendingTempo=true; }
          ciBeatsLeft=ciN;
          subSlot=0; // ensure count-in starts at beat boundary
          state = (ciN>0)? 'countin' : 'beats';
        }
      }

      function loopTick(){ tick(); }
      tick();
      if(loop) clearInterval(loop);
      loop=setInterval(loopTick, 25);
    });
  }

  function stop(){
    running=false;
    loop && clearInterval(loop); loop=null;
    statusEl.textContent='Stopped';
    startBtn.textContent='Start';
  }

  // Start/Stop button
  startBtn.addEventListener('click', ()=> running?stop():start());

  // Space toggles start/stop (not when typing in inputs or select open)
  document.addEventListener('keydown', (e)=>{
    if(e.code === 'Space' || e.key === ' '){
      const tag = (document.activeElement && document.activeElement.tagName) || '';
      const isTyping = /INPUT|TEXTAREA|SELECT/.test(tag);
      if(!isTyping){
        e.preventDefault();
        running ? stop() : start();
      }
    }
  });
})();</script>
</body>
</html>
