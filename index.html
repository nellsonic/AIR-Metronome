<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A.I.R. Metronome â€” 2-Panel, Half-BPM, Stop-at-Limit, Bias Down/Up</title>
<style>
  :root{
    /* Theme tokens */
    --bg:#0d1117; --fg:#e6edf3; --muted:#9fb0c3; --line:#2b3444; --panel:#0f1623;
    --accent:#4fb3ff; --ok:#49d39e; --gold:#ffcc3d; --danger:#ff6b6b;
    --input:#111a2b; --chip:#172235;

    /* UI scale tokens */
    --radii:12px;
    --radii-lg:16px;
    --gap-s:6px;
    --gap-m:12px;
    --gap-l:20px;

    --focus: 0 0 0 2px rgba(79,179,255,.4);
  }
  
  [data-theme="blue"]{
    /* Deep slate-blue surfaces inspired by ICU blue theme */
    --bg:#243b59;
    --fg:#f5f8ff;
    --muted:#afc3db;
    --line:#3b4f73;
    --panel:#2c4870;
    --input:#335386;
    --chip:#355a8d;
    --accent:#60a5fa;
    --ok:#34d399;
    --gold:#fbbf24;
  }

[data-theme="light"]{
    --bg:#f4efe7; --fg:#1d2430; --muted:#5a606b; --line:#d4c8b4;
    --panel:#f5f1ea; --input:#ffffff; --chip:#fff9ef;
    /* Warmer accent so light theme has its own checkbox/slider color */
    --accent:#888888; --ok:#0f8e64; --gold:#b07d00;
  }
  [data-theme="yellow"]{
    --bg:#e1b507; --fg:#17130a; --muted:#3a301a; --line:#d0a908;
    --panel:#f6d54a; --input:#fff4b4; --chip:#ffe780;
    --accent:#d9852b; --ok:#0f6c4a; --gold:#7a5600;
  }
  [data-theme="red"]{
    --bg:#25080b; --fg:#ffecec; --muted:#ffb3b3; --line:#62222a;
    --panel:#2e0e13; --input:#3a141a; --chip:#47171d;
    --accent:#ff8aa0; --ok:#62e0b9; --gold:#ffd56b;
  }
  [data-theme="green"]{
    --bg:#0b1c18; --fg:#e6fff7; --muted:#9ad5c3; --line:#1d3a33;
    --panel:#0f2621; --input:#12312a; --chip:#163b34;
    --accent:#7fe8ff; --ok:#56f0b9; --gold:#ffe18a;
  }

  body{
    background:var(--bg);
    color:var(--fg);
    font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Inter,Arial,sans-serif;
    font-size:15px;
    line-height:1.45;
    margin:0;
    transition: background .25s ease, color .25s ease;
    overflow-x:hidden;
  }
  .wrap{max-width:980px; margin:24px auto 56px; padding:0 16px;}
  h1{margin:0 0 10px; font-weight:900; font-size:22px; letter-spacing:.2px;}
  .top{display:flex; align-items:center; justify-content:space-between; gap:12px}
  .tempo{font-size:36px; font-weight:900; letter-spacing:.5px}

  select,
  input[type=number],
  input[type=text]{
    width:100%;
    padding:8px 10px;
    border-radius:var(--radii);
    border:1px solid var(--line);
    background:var(--input);
    color:var(--fg);
    transition: box-shadow .15s ease, border-color .15s ease, background-color .15s ease;
  }
  /* Narrow numeric/text inputs so paired fields don't collide, and to improve small-screen layout */
  input[type=number],
  input[type=text]{
    max-width:140px;
  }


  input[type=checkbox]{
    width:18px;
    height:18px;
    cursor:pointer;
    accent-color:var(--accent);
  }
  #includeSubdivisionsInCountOff,
  #applyToCountIn{
    accent-color:var(--accent);
  }

  input[type=range]{
    -webkit-appearance:none;
    appearance:none;
    width:100%;
    height:4px;
    border-radius:999px;
    background:var(--line);
    outline:none;
    margin:4px 0;
  }
  input[type=range]::-webkit-slider-thumb{
    -webkit-appearance:none;
    appearance:none;
    width:18px;
    height:18px;
    border-radius:50%;
    background:var(--accent);
    border:2px solid #00000040;
    cursor:pointer;
    box-shadow:0 0 0 1px #00000033;
  }
  input[type=range]::-moz-range-track{
    height:4px;
    border-radius:999px;
    background:var(--line);
  }
  input[type=range]::-moz-range-thumb{
    width:18px;
    height:18px;
    border-radius:50%;
    background:var(--accent);
    border:2px solid #00000040;
    cursor:pointer;
    box-shadow:0 0 0 1px #00000033;
  }

  select:focus,
  input:focus{
    outline:none;
    box-shadow: var(--focus);
    border-color: transparent;
  }

  .btn{
    padding:10px 16px;
    border-radius:999px;
    border:1px solid var(--line);
    background:var(--chip);
    color:var(--fg);
    cursor:pointer;
    font-weight:600;
    transition: box-shadow .15s ease, filter .12s ease, transform .08s ease;
  }
  .btn:hover{ filter:brightness(1.03); transform:translateY(-0.5px); }
  .btn:active{ transform:translateY(0); filter:brightness(0.98); }
  .btn:focus{
    outline:none;
    box-shadow: var(--focus);
    border-color: transparent;
  }
  .btn.primary{
    border:none;
    background:linear-gradient(135deg,
      color-mix(in oklab, var(--accent) 72%, #ffffff),
      var(--accent)
    );
    color:#06101b;
    font-weight:700;
    box-shadow:0 10px 24px rgba(0,0,0,.25);
  }

  .status{font-size:12px; color:var(--muted)}
  .panel{
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:var(--radii-lg);
    padding:14px;
    box-shadow:0 10px 26px rgba(0,0,0,.25);
  }
  .grid{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(210px,1fr));
    gap:var(--gap-m);
  }
  .panel.large .grid{
    grid-template-columns: repeat(2, minmax(0,1fr));
  }

  /* Explicit placement for first four fields on wide screens */
  @media (min-width: 720px){
    .panel.large .grid{
      grid-auto-flow: row;
    }
    .panel.large .grid .field-start{ grid-row:1; grid-column:1; }
    .panel.large .grid .field-beats{ grid-row:1; grid-column:2; }
    .panel.large .grid .field-min{ grid-row:2; grid-column:1; }
    .panel.large .grid .field-max{ grid-row:2; grid-column:2; }
  }
  @media (max-width: 719px){
    /* On small screens, let fields stack naturally */
    .panel.large .grid .field-start,
    .panel.large .grid .field-beats,
    .panel.large .grid .field-min,
    .panel.large .grid .field-max{
      grid-row:auto;
      grid-column:auto;
    }
  }

  .field label{
    display:block;
    color:var(--muted);
    font-size:12px;
    margin-bottom:5px;
  }
  .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
  .dot{
    width:14px;
    height:14px;
    border-radius:50%;
    background:#5a6578;
    display:inline-block;
    margin-left:8px;
  }
  .inline{display:flex; align-items:center; gap:8px}
  .help{font-size:12px; color:var(--muted); margin-top:8px}
  .foot{margin-top:12px; font-size:12px; color:var(--muted)}
  .sr{position:absolute; left:-9999px}

  .panelRow{
    display:flex;
    gap:var(--gap-m);
    align-items:flex-start;
    flex-wrap:wrap;
    margin-top:16px;
  }
  .panel.small{
    flex:0 0 260px;
    max-width:280px;
  }
  .panel.large{
    flex:1 1 0;
  }

  .subsRow{
    display:flex;
    gap:10px;
    margin-top:8px;
    flex-wrap:nowrap;
  }
  .subBox{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    padding:0;
    margin:0;
    background:transparent;
    border:none;
    width:auto;
    height:auto;
  }
  .subBox input{
    margin:0;
  }
</style>
</head>
<body data-theme="dark">
<div class="wrap">
  <div class="top">
    <div>
      <h1>Automatic Incremental & Randomizing (A.I.R.) Metronome</h1>
      <div class="inline">
        <div class="tempo"><span id="tempoNow">60</span></div>
        <span class="status" id="status">Stopped</span>
        <span class="dot" id="pulse"></span>
      </div>
    </div>
    <div class="inline">
      <label class="sr" for="theme">Theme</label>
      <select id="theme">
        <option value="dark">Dark</option>
        <option value="blue">Blue</option>
        <option value="light">Light</option>
        <option value="yellow">Yellow</option>
        <option value="red">Red</option>
        <option value="green">Green</option>
      </select>
      <button class="btn primary" id="startStop">Start</button>
    </div>
  </div>

  <div class="panelRow">
    <div class="panel large">
      <div class="grid">
        <div class="field field-start"><label>Start Tempo</label><input id="startTempo" type="number" value="60" min="20" max="300" step="1"></div>
        <div class="field field-min"><label>Min Tempo</label><input id="minTempo" type="number" value="40" min="20" max="300" step="1"></div>
        <div class="field field-max"><label>Max Tempo</label><input id="maxTempo" type="number" value="180" min="20" max="300" step="1"></div>
        <div class="field field-beats"><label>Beats per Tempo</label><input id="beatsPerTempo" type="number" value="4" min="1" max="16"></div>
        <div class="field"><label>Repeats per Tempo</label><input id="repeatsPerTempo" type="number" value="2" min="1" max="64"></div>
        <div class="field"><label>Count-In Beats (every cycle)</label><input id="countInBeats" type="number" value="2" min="0" max="16"></div>

        <div class="field"><label>Min Change</label><input id="minStep" type="number" value="1" min="0.5" max="60" step="1"></div>
        <div class="field"><label>Max Change</label><input id="maxStep" type="number" value="5" min="0.5" max="60" step="1"></div>

        <div class="field">
          <label class="inline">
            <input id="allowHalfSteps" type="checkbox">
            <span>Allow 0.5 tempo values</span>
          </label>
        </div>

        <div class="field">
          <label>Bias (Down/Up)</label>
          <div class="row">
            <input id="biasDown" type="number" min="0" max="100" value="50" style="max-width:64px;">
            <span>/</span>
            <input id="biasUp" type="number" min="0" max="100" value="50" style="max-width:64px;">
          </div>
          <input id="biasSlider" type="range" value="50" min="0" max="100" step="1" style="margin-top:6px;">
          <div id="biasHelp" class="help">100/0 = Always Down, 0/100 = Always Up, 50/50 = Neutral</div>
        </div>

        <div class="field"><label>Volume</label><input id="volume" type="range" value="60" min="0" max="100"></div>

        <div class="field">
          <label class="inline">
            <input id="stopAtLimit" type="checkbox">
            <span>Stop After Max/Min Tempo</span>
          </label>
        </div>

        <div class="field">
          <label>Stop after (minutes)</label>
          <input id="stopAfterMinutes" type="number" value="0" min="0" max="36000" step="0.1">
          <div class="help">0 = No time limit. Metronome will stop after this many minutes if greater than 0.</div>
        </div>
      </div>

      <div class="foot">Live volume preview when stopped: move the volume slider. Space bar also starts and stops the metronome.</div>
    </div>

    <div class="panel small">
      <div class="field">
        <label>Subdivisions per Beat</label>
        <select id="subsPerBeat">
          <option value="1">Quarters</option>
          <option value="2">8th's</option>
          <option value="3">Triplets</option>
          <option value="4">16ths</option>
          <option value="5">5's</option>
          <option value="6">6's</option>
          <option value="7">7's</option>
        </select>
        <div class="subsRow" id="subList"></div>
        <div class="help">Uncheck boxes to mute subdivisions.</div>
        <button class="btn" id="resetMute" style="margin-top:8px;">Unmute All</button>
      </div>

      <div class="field">
        <label class="inline" for="includeSubdivisionsInCountOff">
          <input id="includeSubdivisionsInCountOff" type="checkbox" />
          <span>Include subdivisions in count-off</span>
        </label>
      </div>

      <div class="field">
        <label class="inline">
          <input id="applyToCountIn" type="checkbox"/>
          <span>Apply muting to count-in</span>
        </label>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const root = document.body;
  const themeSel = document.getElementById('theme');
  themeSel.addEventListener('change', ()=> themeSel.blur());
  const pulse = document.getElementById('pulse');
  themeSel.addEventListener('change', () => { root.setAttribute('data-theme', themeSel.value); });
  root.setAttribute('data-theme', themeSel.value);

  const tempoNow = document.getElementById('tempoNow');
  const statusEl = document.getElementById('status');
  const startBtn = document.getElementById('startStop');
  const startTempo = document.getElementById('startTempo');
  const minTempo = document.getElementById('minTempo');
  const maxTempo = document.getElementById('maxTempo');
  const beatsPerTempo = document.getElementById('beatsPerTempo');
  const repeatsPerTempo = document.getElementById('repeatsPerTempo');
  const countInBeats = document.getElementById('countInBeats');
  const subsPerBeat = document.getElementById('subsPerBeat');
  const minStep = document.getElementById('minStep');
  const maxStep = document.getElementById('maxStep');
  const allowHalfSteps = document.getElementById('allowHalfSteps');
  const biasDown = document.getElementById('biasDown');
  const biasUp = document.getElementById('biasUp');
  const biasSlider = document.getElementById('biasSlider');
  const volume = document.getElementById('volume');
  const subList = document.getElementById('subList');
  const applyToCountIn = document.getElementById('applyToCountIn');
  const includeSubdivisionsInCountOff = document.getElementById('includeSubdivisionsInCountOff');
  const resetMute = document.getElementById('resetMute');
  const stopAtLimit = document.getElementById('stopAtLimit');
  const stopAfterMinutes = document.getElementById('stopAfterMinutes');

  // Blur sliders after use so spacebar controls transport
  document.querySelectorAll('input[type="range"]').forEach(r => {
    const blurIt = () => r.blur();
    r.addEventListener('mouseup', blurIt);
    r.addEventListener('touchend', blurIt);
    r.addEventListener('change', blurIt);
  });

  // Number inputs: select value on focus/click so typing replaces it,
  // but do not interfere with spinner behavior (no preventDefault).
  document.querySelectorAll('input[type="number"]').forEach(n => {
    n.addEventListener('focus', () => {
      setTimeout(() => n.select(), 0);
    });
    n.addEventListener('mouseup', () => {
      // After a click into the field, re-select the value so typing replaces it,
      // while still allowing the browser to handle spinner clicks normally.
      setTimeout(() => {
        if (document.activeElement === n) {
          n.select();
        }
      }, 0);
    });
  });

  function isNum(v){ return v !== '' && v !== null && v !== undefined && !isNaN(Number(v)); }
  function getHalfMode(){ return !!(allowHalfSteps && allowHalfSteps.checked); }
  function roundToTempoUnit(v){
    v = Number(v);
    if (!Number.isFinite(v)) v = 0;
    if (getHalfMode()){
      return Math.round(v * 2) / 2;
    }
    return Math.round(v);
  }
  function formatTempoValue(v){
    const val = roundToTempoUnit(v);
    if (getHalfMode() && val % 1 !== 0){
      return val.toFixed(1);
    }
    return String(Math.round(val));
  }
  function getStepUnit(){
    return getHalfMode() ? 0.5 : 1;
  }

  // Bias Down/Up
  let biasDownValue = 50;
  function syncBiasUI(){
    const down = Math.min(100, Math.max(0, Math.round(biasDownValue)));
    const up = 100 - down;
    biasDown.value = String(down);
    biasUp.value = String(up);
    biasSlider.value = String(up); // slider shows Up%
  }
  function setBiasFromDown(raw){
    const v = Number(raw);
    if (!Number.isFinite(v)) return;
    biasDownValue = Math.min(100, Math.max(0, Math.round(v)));
    syncBiasUI();
  }
  function setBiasFromUp(raw){
    const v = Number(raw);
    if (!Number.isFinite(v)) return;
    const up = Math.min(100, Math.max(0, Math.round(v)));
    biasDownValue = 100 - up;
    syncBiasUI();
  }
  biasSlider.addEventListener('input', ()=>{ setBiasFromUp(biasSlider.value); });
  syncBiasUI();

  let syncingRange = false;
  function enforceRange(sourceId){
    if (syncingRange) return;
    if (!isNum(minTempo.value) || !isNum(maxTempo.value) || !isNum(startTempo.value)) return;

    syncingRange = true;
    let minV = Number(minTempo.value);
    let maxV = Number(maxTempo.value);
    let startV = Number(startTempo.value);

    if (sourceId === 'maxTempo') {
      if (maxV < minV) { minV = maxV; }
      if (startV < minV || startV > maxV) { startV = minV; }
    } else if (sourceId === 'minTempo') {
      if (minV > maxV) { maxV = minV; }
      if (startV < minV || startV > maxV) { startV = minV; }
    } else if (sourceId === 'startTempo') {
      if (startV < minV) { minV = startV; }
      if (startV > maxV) { maxV = startV; }
    } else {
      if (minV > maxV) { maxV = minV; }
      if (startV < minV || startV > maxV) { startV = minV; }
    }

    minV = roundToTempoUnit(minV);
    maxV = roundToTempoUnit(maxV);
    startV = roundToTempoUnit(startV);

    minTempo.value = formatTempoValue(minV);
    maxTempo.value = formatTempoValue(maxV);
    startTempo.value = formatTempoValue(startV);

    syncingRange = false;
  }

  function enforceStepRange(sourceId){
    let minV = Number(minStep.value);
    let maxV = Number(maxStep.value);
    if (!isNum(minV) || !isNum(maxV)) return;

    const unit = getStepUnit();
    if (minV < unit) minV = unit;
    if (maxV < unit) maxV = unit;
    if (minV > maxV){
      if (sourceId === 'minStep') { maxV = minV; }
      else { minV = maxV; }
    }
    minV = Math.round(minV / unit) * unit;
    maxV = Math.round(maxV / unit) * unit;

    minStep.value = (unit === 0.5 && minV % 1 !== 0) ? minV.toFixed(1) : String(minV);
    maxStep.value = (unit === 0.5 && maxV % 1 !== 0) ? maxV.toFixed(1) : String(maxV);
  }

  function applyHalfStepUI(){
    const unit = getStepUnit();
    const stepStr = unit === 0.5 ? "0.5" : "1";
    [startTempo, minTempo, maxTempo, minStep, maxStep].forEach(el=>{
      if (el) el.step = stepStr;
    });
    enforceRange();
    enforceStepRange();
  }

  function bindCommit(el, onCommit){
    const commit = () => { onCommit && onCommit(); };
    el.addEventListener('change', commit);
    el.addEventListener('blur', commit);
    el.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' || e.code === 'Enter' || e.code === 'NumpadEnter' || e.keyCode === 13) {
        e.preventDefault();
        commit();
        el.blur();
      }
    });
    el.addEventListener('keyup', (e)=>{
      if (e.key === 'Enter' || e.code === 'Enter' || e.code === 'NumpadEnter' || e.keyCode === 13) {
        commit();
      }
    });
  }

  bindCommit(minTempo, ()=>enforceRange('minTempo'));
  bindCommit(maxTempo, ()=>enforceRange('maxTempo'));
  bindCommit(startTempo, ()=>enforceRange('startTempo'));

  bindCommit(beatsPerTempo, ()=>{});
  bindCommit(repeatsPerTempo, ()=>{});
  bindCommit(countInBeats, ()=>{});
  bindCommit(subsPerBeat, ()=>{ buildSubList(); });
  bindCommit(minStep, ()=>{ enforceStepRange('minStep'); });
  bindCommit(maxStep, ()=>{ enforceStepRange('maxStep'); });
  bindCommit(biasDown, ()=>{ setBiasFromDown(biasDown.value); });
  bindCommit(biasUp, ()=>{ setBiasFromUp(biasUp.value); });

  const STORAGE_KEY = 'airMetronomeState_v1';

  function saveState(){
    const st = {};
    st.theme = themeSel.value;

    function grab(el, key){
      if(!el) return;
      const type = (el.getAttribute('type') || '').toLowerCase();
      if(type === 'checkbox'){
        st[key] = !!el.checked;
      }else{
        st[key] = el.value;
      }
    }

    grab(allowHalfSteps, 'allowHalfSteps');
    grab(startTempo, 'startTempo');
    grab(minTempo, 'minTempo');
    grab(maxTempo, 'maxTempo');
    grab(beatsPerTempo, 'beatsPerTempo');
    grab(repeatsPerTempo, 'repeatsPerTempo');
    grab(countInBeats, 'countInBeats');
    grab(minStep, 'minStep');
    grab(maxStep, 'maxStep');
    grab(biasDown, 'biasDown');
    grab(biasUp, 'biasUp');
    grab(volume, 'volume');
    grab(subsPerBeat, 'subsPerBeat');
    grab(applyToCountIn, 'applyToCountIn');
    grab(includeSubdivisionsInCountOff, 'includeSubdivisionsInCountOff');
    grab(stopAtLimit, 'stopAtLimit');
    grab(stopAfterMinutes, 'stopAfterMinutes');

    const mutes = [...subList.querySelectorAll('input[type=checkbox]')].map(cb => cb.checked);
    st.subMutes = mutes;

    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify(st));
    }catch(e){}
  }

  function loadState(){
    let raw = null;
    try{
      raw = localStorage.getItem(STORAGE_KEY);
    }catch(e){
      raw = null;
    }
    if(!raw){
      return;
    }
    let st;
    try{
      st = JSON.parse(raw);
    }catch(e){
      return;
    }
    if(!st || typeof st !== 'object') return;

    if(st.theme){
      themeSel.value = st.theme;
      root.setAttribute('data-theme', themeSel.value);
    }

    function setVal(el, key){
      if(!el) return;
      if(!(key in st)) return;
      const v = st[key];
      const type = (el.getAttribute('type') || '').toLowerCase();
      if(type === 'checkbox'){
        el.checked = !!v;
      }else{
        el.value = String(v);
      }
    }

    setVal(allowHalfSteps, 'allowHalfSteps');
    setVal(startTempo, 'startTempo');
    setVal(minTempo, 'minTempo');
    setVal(maxTempo, 'maxTempo');
    setVal(beatsPerTempo, 'beatsPerTempo');
    setVal(repeatsPerTempo, 'repeatsPerTempo');
    setVal(countInBeats, 'countInBeats');
    setVal(minStep, 'minStep');
    setVal(maxStep, 'maxStep');
    setVal(biasDown, 'biasDown');
    setVal(biasUp, 'biasUp');
    setVal(volume, 'volume');
    setVal(subsPerBeat, 'subsPerBeat');
    setVal(applyToCountIn, 'applyToCountIn');
    setVal(includeSubdivisionsInCountOff, 'includeSubdivisionsInCountOff');
    setVal(stopAtLimit, 'stopAtLimit');
    setVal(stopAfterMinutes, 'stopAfterMinutes');

    // Apply mode-dependent constraints and rebuild subs
    applyHalfStepUI();
    enforceRange();
    enforceStepRange();
    buildSubList();

    if(Array.isArray(st.subMutes)){
      const cbs = [...subList.querySelectorAll('input[type=checkbox]')];
      for(let i=0;i<cbs.length && i<st.subMutes.length;i++){
        cbs[i].checked = !!st.subMutes[i];
      }
    }

    // Show current start tempo in display
    if(startTempo && tempoNow){
      tempoNow.textContent = formatTempoValue(startTempo.value || 60);
    }
  }

  // Persist on any input/select change
  document.addEventListener('change', (e)=>{
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT')){
      saveState();
    }
  });

  // Load saved state (if any) after wiring persistence
  loadState();

  enforceRange();
  enforceStepRange();
  applyHalfStepUI();

  if (allowHalfSteps){
    allowHalfSteps.addEventListener('change', ()=>{
      applyHalfStepUI();
    });
  }

  function snapStepInputIfNeeded(el){
    if(getHalfMode()) return;
    let v = Number(el.value);
    if(!Number.isFinite(v)) return;
    const snapped = Math.round(v);
    if(el.value !== String(snapped)){
      el.value = String(snapped);
    }
  }
  minStep.addEventListener('input', ()=>{ snapStepInputIfNeeded(minStep); });
  maxStep.addEventListener('input', ()=>{ snapStepInputIfNeeded(maxStep); });

  resetMute.addEventListener('click', () => {
    [...subList.querySelectorAll('input[type=checkbox]')].forEach(cb=>cb.checked=true);
  });

  function buildSubList(){
    const n = Math.max(1, +subsPerBeat.value||1);
    subList.innerHTML='';
    for(let i=1;i<=n;i++){
      const id='submute_'+i;
      const li=document.createElement('label'); 
      li.className='subBox';
      li.innerHTML=`<input type="checkbox" id="${id}" checked aria-label="Subdivision ${i}">`;
      const cb = li.querySelector('input');
      cb.addEventListener('change', () => { cb.blur(); });
      subList.appendChild(li);
    }
  }
  buildSubList();

  includeSubdivisionsInCountOff.addEventListener('change', () => {
    includeSubdivisionsInCountOff.blur();
  });
  applyToCountIn.addEventListener('change', () => {
    applyToCountIn.blur();
  });

  let ctx, buffers={};
  const AC = window.AudioContext || window.webkitAudioContext;
  function ensureCtx(){ if(!ctx){ ctx = new AC(); } return ctx.resume(); }
  function flash(kind){
    pulse.style.background = kind==='ci'
      ? 'var(--gold)'
      : kind==='beat'
      ? 'var(--accent)'
      : 'var(--ok)';
    setTimeout(()=>pulse.style.background='#5a6578',85);
  }
  function makeTone(hz, len=0.038, decay=38){
    const sr=ctx.sampleRate, n=Math.floor(sr*len), buf=ctx.createBuffer(1,n,sr), ch=buf.getChannelData(0);
    for(let i=0;i<n;i++){
      const tt=i/sr;
      ch[i]=Math.sin(2*Math.PI*hz*tt)*Math.exp(-tt*decay);
    }
    return buf;
  }
  async function loadBuffers(){
    if(Object.keys(buffers).length) return;
    await ensureCtx();
    buffers.ci   = makeTone(1400,0.045,42);
    buffers.beat = makeTone(950,0.040,40);
    buffers.sub  = makeTone(620,0.036,36);
    buffers.cisub = makeTone(940,0.036,36);
  }
  function play(bufName, when, gainMul=0.85){
    const now = ctx.currentTime;
    const src = ctx.createBufferSource(); src.buffer=buffers[bufName];
    const g = ctx.createGain(); g.gain.value = (parseInt(volume.value,10)/100)*gainMul;
    src.connect(g).connect(ctx.destination);
    src.start(Math.max(when, now));
  }

  let running=false;
  volume.addEventListener('input', ()=>{
    if(!running){
      ensureCtx().then(loadBuffers).then(()=>{
        play('beat', ctx.currentTime+0.02, 0.5);
      });
    }
  });

  let loop=null;
  function clampTempo(v){
    let lo = Number(minTempo.value);
    let hi = Number(maxTempo.value);
    if (!Number.isFinite(lo)) lo = 20;
    if (!Number.isFinite(hi)) hi = 300;
    let val = roundToTempoUnit(v);
    if (val < lo) val = lo;
    if (val > hi) val = hi;
    return val;
  }

  function stepSize(){
    let minV = Number(minStep.value);
    let maxV = Number(maxStep.value);
    const unit = getStepUnit();

    if (!isNum(minV) || !isNum(maxV)){
      minV = unit;
      maxV = unit;
    }
    if (minV < unit) minV = unit;
    if (maxV < unit) maxV = unit;
    if (minV > maxV){
      const t = minV;
      minV = maxV;
      maxV = t;
    }

    let size;
    if (unit === 0.5){
      const stepsCount = Math.floor((maxV - minV) / unit + 0.0000001);
      const k = Math.floor(Math.random() * (stepsCount + 1));
      size = minV + k * unit;
      size = Math.round(size * 2) / 2;
    } else {
      const span = Math.max(0, maxV - minV);
      const k = Math.floor(Math.random() * (span + 1));
      size = minV + k;
    }

    const down = biasDownValue;
    const pUp = Math.max(0, Math.min(1, (100 - down) / 100));
    const goUp = Math.random() < pUp;
    return goUp ? size : -size;
  }

  function mutedMask(n){
    const cbs=[...subList.querySelectorAll('input[type=checkbox]')];
    if(cbs.length!==n) return new Array(n).fill(true);
    return cbs.map(cb=>cb.checked);
  }

  function start(){
    if(running) return;
    running=true;
    ensureCtx().then(loadBuffers).then(()=>{
      let tempo = clampTempo(+startTempo.value||60);
      let bpt   = Math.max(1, +beatsPerTempo.value||4);
      let rptN  = Math.max(1, +repeatsPerTempo.value||1);
      let sub   = Math.max(1, +subsPerBeat.value||1);
      let ciN   = Math.max(0, +countInBeats.value||0);
      let mask  = mutedMask(sub);
      let includeMuteInCI = applyToCountIn.checked;
      let includeSubsInCI = includeSubdivisionsInCountOff && includeSubdivisionsInCountOff.checked;

      let beatInterval = 60/tempo;
      let subInterval  = beatInterval/sub;
      let next = ctx.currentTime + 0.12;

      let state = (ciN>0)? 'countin' : 'beats';
      let ciBeatsLeft=ciN;
      let beatIdx=0;
      let subSlot = 0;
      let repsDone=0;
      let stopDeadline = null;
      const stopMinRaw = Number(stopAfterMinutes && stopAfterMinutes.value);
      const stopSecRaw = (isNum(stopMinRaw) && stopMinRaw > 0) ? stopMinRaw * 60 : 0;
      if (isNum(stopSecRaw) && stopSecRaw > 0) {
        stopDeadline = ctx.currentTime + stopSecRaw;
      }


      tempoNow.textContent = formatTempoValue(tempo);
      statusEl.textContent = 'Running';
      startBtn.textContent = 'Stop';

      function refresh(){
        beatInterval = 60/tempo;
        subInterval  = beatInterval/sub;
      }

      function tempoAdvance(){
        const delta = stepSize();
        tempo = clampTempo(tempo + delta);
        tempoNow.textContent = formatTempoValue(tempo);
        bpt  = Math.max(1, +beatsPerTempo.value||4);
        rptN = Math.max(1, +repeatsPerTempo.value||1);
        ciN  = Math.max(0, +countInBeats.value||0);
        refresh();
      }

      const lookahead=0.12;
      function tick(){
        while(next < ctx.currentTime + lookahead){
          if (stopDeadline !== null && next >= stopDeadline) {
            stop();
            return;
          }
          const newSub = Math.max(1, +subsPerBeat.value||1);
          if(newSub !== sub){
            sub = newSub;
            subSlot = 0;
            refresh();
          }
          mask  = mutedMask(sub);
          includeMuteInCI = applyToCountIn && applyToCountIn.checked;
          includeSubsInCI = includeSubdivisionsInCountOff && includeSubdivisionsInCountOff.checked;

          if(state==='countin'){
            const includeSubsCI = includeSubsInCI;
            if(subSlot===0){
              play('ci', next, 0.95); flash('ci');
              if(includeSubsCI){
                subSlot = 1;
                subInterval = (60/tempo)/sub;
                next += subInterval;
              } else {
                next += (60/tempo);
                ciBeatsLeft--;
                if(ciBeatsLeft === 0){
                  beatIdx = 0; subSlot = 0; state = 'beats';
                }
              }
              continue;
            }
            if(includeSubsCI && subSlot < sub){
              const applyMuteCI = includeMuteInCI;
              const shouldPlay = applyMuteCI ? !!mask[subSlot] : true;
              if(shouldPlay){ play('cisub', next, 0.55); flash('sub'); }
              subSlot++;
              next += subInterval;
              if(subSlot < sub) continue;
              ciBeatsLeft--;
              subSlot = 0;
              if(ciBeatsLeft === 0){
                beatIdx = 0; state = 'beats';
              }
              continue;
            }
          }

          if(subSlot===0){
            refresh();
            play('beat', next, 0.85); flash('beat');
            subSlot=1;
            next += subInterval; continue;
          }
          if(subSlot < sub){
            if(mask[subSlot]){ play('sub', next, 0.55); flash('sub'); }
            subSlot++;
            next += subInterval;
            if(subSlot < sub) continue;
          }

          beatIdx++;
          if(beatIdx < bpt){ subSlot=0; continue; }

          // cycle finished
          beatIdx=0;
          repsDone++;
          if(repsDone >= rptN){
            repsDone=0;
            if (stopAtLimit && stopAtLimit.checked){
              const mn = Number(minTempo.value);
              const mx = Number(maxTempo.value);
              if ((isNum(mn) && tempo <= mn) || (isNum(mx) && tempo >= mx)){
                stop();
                return;
              }
            }
            tempoAdvance();
          }
          ciBeatsLeft=ciN;
          subSlot=0;
          state = (ciN>0)? 'countin' : 'beats';
        }
      }

      function loopTick(){ tick(); }
      tick();
      if(loop) clearInterval(loop);
      loop=setInterval(loopTick, 25);
    });
  }

  function stop(){
    running=false;
    if(loop){ clearInterval(loop); loop=null; }
    statusEl.textContent='Stopped';
    startBtn.textContent='Start';
  }

  startBtn.addEventListener('click', ()=> running?stop():start());

  function isSpaceEvent(e){
    return (
      e.code === 'Space' ||
      e.key === ' ' ||
      e.key === 'Spacebar' ||
      e.keyCode === 32 ||
      e.which === 32
    );
  }

  document.addEventListener('keydown', (e)=>{
    if(!isSpaceEvent(e)) return;

    const active = document.activeElement;
    const tag = active && active.tagName;
    let isTyping = false;

    if(tag){
      if(tag === 'INPUT'){
        const type = (active.getAttribute('type') || '').toLowerCase();
        if(type === 'checkbox' || type === 'radio'){
          isTyping = false;
        } else if(type === 'range' || type === 'number'){
          // For sliders and numeric boxes, space should control transport,
          // not attempt to type a space.
          isTyping = false;
        } else {
          isTyping = true;
        }
      } else if(tag === 'TEXTAREA'){
        isTyping = true;
      } else if(tag === 'SELECT'){
        // Dropdowns shouldn't block transport controls.
        isTyping = false;
      }
    }

    if(isTyping) return;

    e.preventDefault();
    running ? stop() : start();
  });

})();</script>
</body>
</html>
